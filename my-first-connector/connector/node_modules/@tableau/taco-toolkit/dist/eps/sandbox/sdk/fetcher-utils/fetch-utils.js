"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFetchParams = exports.ingestDataRows = exports.loadParquetData = exports.loadData = exports.loadCsvData = exports.fetchArrayBuffer = exports.fetchJson = void 0;
var csv_stringify_1 = require("csv-stringify");
var fs_1 = __importDefault(require("fs"));
var node_path_1 = __importDefault(require("node:path"));
var node_stream_1 = require("node:stream");
var node_util_1 = require("node:util");
var type_utils_1 = require("../../../../shared/type-utils");
var handler_input_1 = require("../../../../shared/types/handler-input");
var permission_1 = require("../../../../shared/types/permission");
var extractor_cache_1 = __importDefault(require("../../../extractor/extractor-cache"));
var eps_logger_1 = require("../../../logging/eps-logger");
var parse_utils_1 = require("../../../utils/parse-utils");
var request_utils_1 = require("../../../utils/request-utils");
var sandbox_plugin_1 = require("../sandbox-plugin");
// Convert the pipeline function to a promise so we can use async/await with it
var streamPipeline = (0, node_util_1.promisify)(node_stream_1.pipeline);
var FetchUtilsPlugin = /** @class */ (function (_super) {
    __extends(FetchUtilsPlugin, _super);
    function FetchUtilsPlugin() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FetchUtilsPlugin.prototype.init = function () {
        var methods = [
            {
                isStatic: true,
                externalName: 'fetchJson',
                functionRef: createFetchJson(this),
            },
            {
                isStatic: true,
                externalName: 'fetchArrayBuffer',
                functionRef: createFetchArrayBuffer(this),
            },
            {
                isStatic: true,
                externalName: 'loadData',
                functionRef: createLoadData(this),
            },
            {
                isStatic: true,
                externalName: 'loadExcelData',
                functionRef: createLoadExcelData(this),
            },
            {
                isStatic: true,
                externalName: 'loadParquetData',
                functionRef: createLoadParquetData(this),
            },
            {
                isStatic: true,
                externalName: 'loadCsvData',
                functionRef: createLoadCsvData(this),
            },
            {
                isStatic: true,
                externalName: 'ingestDataRows',
                functionRef: createIngestDataRows(this),
            },
        ];
        this.createClass(methods, 'FetchUtils');
    };
    return FetchUtilsPlugin;
}(sandbox_plugin_1.SandboxPlugin));
exports.default = FetchUtilsPlugin;
function checkPermission(fetchUtilsSDK, url, method) {
    if (fetchUtilsSDK.sandbox.getPermission()) {
        var permission = fetchUtilsSDK.sandbox.getPermission();
        if (!permission || !permission_1.PermissionChecker.checkApiPermission(permission.api, url, method)) {
            var error = new Error("No permission to make ".concat(method, " request URL ").concat(url));
            eps_logger_1.Logger.error(error);
            throw error;
        }
    }
}
function createFetchJson(fetchUtilsSDK) {
    var _this = this;
    var networkAdapter = fetchUtilsSDK.sandbox.getNetworkAdapter();
    return function (url, options) { return __awaiter(_this, void 0, void 0, function () {
        var method;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    method = (_a = options === null || options === void 0 ? void 0 : options.method) !== null && _a !== void 0 ? _a : 'GET';
                    checkPermission(fetchUtilsSDK, url, method);
                    return [4 /*yield*/, fetchJson(networkAdapter, url, options)];
                case 1: return [2 /*return*/, _b.sent()];
            }
        });
    }); };
}
function createLoadData(fetchUtilsSDK) {
    var _this = this;
    var handlerInput = fetchUtilsSDK.sandbox.getHandlerInput();
    var tempDataManager = fetchUtilsSDK.sandbox.getTempDataManager();
    var networkAdapter = fetchUtilsSDK.sandbox.getNetworkAdapter();
    return function (url, options) { return __awaiter(_this, void 0, void 0, function () {
        var method;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    method = (_a = options === null || options === void 0 ? void 0 : options.method) !== null && _a !== void 0 ? _a : 'GET';
                    checkPermission(fetchUtilsSDK, url, method);
                    return [4 /*yield*/, loadData(handlerInput, tempDataManager, networkAdapter, url, options)];
                case 1: return [2 /*return*/, _b.sent()];
            }
        });
    }); };
}
function createLoadExcelData(fetchUtilsSDK) {
    return createLoadData(fetchUtilsSDK);
}
function createLoadParquetData(fetchUtilsSDK) {
    var _this = this;
    var handlerInput = fetchUtilsSDK.sandbox.getHandlerInput();
    var tempDataManager = fetchUtilsSDK.sandbox.getTempDataManager();
    var networkAdapter = fetchUtilsSDK.sandbox.getNetworkAdapter();
    var tableFileCounter = {};
    return function (url, options) { return __awaiter(_this, void 0, void 0, function () {
        var method;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    method = (_a = options === null || options === void 0 ? void 0 : options.method) !== null && _a !== void 0 ? _a : 'GET';
                    checkPermission(fetchUtilsSDK, url, method);
                    return [4 /*yield*/, loadParquetData(handlerInput, tempDataManager, networkAdapter, tableFileCounter, url, options)];
                case 1: return [2 /*return*/, _b.sent()];
            }
        });
    }); };
}
function createLoadCsvData(fetchUtilsSDK) {
    var _this = this;
    var handlerInput = fetchUtilsSDK.sandbox.getHandlerInput();
    var tempDataManager = fetchUtilsSDK.sandbox.getTempDataManager();
    var networkAdapter = fetchUtilsSDK.sandbox.getNetworkAdapter();
    return function (url, options) { return __awaiter(_this, void 0, void 0, function () {
        var method;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    method = (_a = options === null || options === void 0 ? void 0 : options.method) !== null && _a !== void 0 ? _a : 'GET';
                    checkPermission(fetchUtilsSDK, url, method);
                    return [4 /*yield*/, loadCsvData(handlerInput, tempDataManager, networkAdapter, url, options)];
                case 1: return [2 /*return*/, _b.sent()];
            }
        });
    }); };
}
function createIngestDataRows(fetchUtilsSDK) {
    var _this = this;
    var handlerInput = fetchUtilsSDK.sandbox.getHandlerInput();
    var tempDataManager = fetchUtilsSDK.sandbox.getTempDataManager();
    return function (rows) { return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, ingestDataRows(handlerInput, tempDataManager, rows)];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    }); };
}
function createFetchArrayBuffer(fetchUtilsSDK) {
    var _this = this;
    var networkAdapter = fetchUtilsSDK.sandbox.getNetworkAdapter();
    return function (url, options) { return __awaiter(_this, void 0, void 0, function () {
        var method;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    method = (_a = options === null || options === void 0 ? void 0 : options.method) !== null && _a !== void 0 ? _a : 'GET';
                    checkPermission(fetchUtilsSDK, url, method);
                    return [4 /*yield*/, fetchArrayBuffer(networkAdapter, url, options)];
                case 1: return [2 /*return*/, _b.sent()];
            }
        });
    }); };
}
function fetchJson(networkAdapter, url, options) {
    return __awaiter(this, void 0, void 0, function () {
        var fetchParams, headers, response;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    fetchParams = getFetchParams(url, options);
                    headers = fetchParams.options.headers;
                    if (headers === undefined) {
                        fetchParams.options.headers = headers = {};
                    }
                    headers['Accept'] = 'application/json';
                    return [4 /*yield*/, networkAdapter.fetch(fetchParams.urlWithQuery, fetchParams.options)];
                case 1:
                    response = _a.sent();
                    if (!response.ok || response.body === null) {
                        throw new Error("fetchJson: unexpected response. [status]: ".concat(response.status, ", [statusText]: ").concat(response.statusText));
                    }
                    return [4 /*yield*/, response.json()];
                case 2: return [2 /*return*/, _a.sent()];
            }
        });
    });
}
exports.fetchJson = fetchJson;
function fetchArrayBuffer(networkAdapter, url, options) {
    return __awaiter(this, void 0, void 0, function () {
        var fetchParams, response, buffer;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    fetchParams = getFetchParams(url, options);
                    return [4 /*yield*/, networkAdapter.fetch(fetchParams.urlWithQuery, fetchParams.options)];
                case 1:
                    response = _a.sent();
                    if (!response.ok || response.body === null) {
                        throw new Error("fetchArrayBuffer: unexpected response. [status]: ".concat(response.status, ", [statusText]: ").concat(response.statusText));
                    }
                    return [4 /*yield*/, response.arrayBuffer()];
                case 2:
                    buffer = _a.sent();
                    return [2 /*return*/, new Uint8Array(buffer)];
            }
        });
    });
}
exports.fetchArrayBuffer = fetchArrayBuffer;
function loadCsvData(handlerInput, tempDataManager, networkAdapter, url, options) {
    return __awaiter(this, void 0, void 0, function () {
        function streamToFile(stream, filePath) {
            var _a;
            return __awaiter(this, void 0, void 0, function () {
                var trimColumnHeader, _b;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            trimColumnHeader = (_a = options === null || options === void 0 ? void 0 : options.trimColumnHeader) !== null && _a !== void 0 ? _a : false;
                            _b = !trimColumnHeader || !fs_1.default.existsSync(filePath);
                            if (_b) return [3 /*break*/, 2];
                            return [4 /*yield*/, (0, parse_utils_1.isFileEmpty)(filePath)];
                        case 1:
                            _b = (_c.sent());
                            _c.label = 2;
                        case 2:
                            if (!_b) return [3 /*break*/, 4];
                            return [4 /*yield*/, streamPipeline(stream, fs_1.default.createWriteStream(filePath, { flags: 'a' }))];
                        case 3:
                            _c.sent();
                            return [3 /*break*/, 6];
                        case 4: return [4 /*yield*/, streamPipeline(stream.pipe(new FirstLineTransform()), fs_1.default.createWriteStream(filePath, { flags: 'a' }))];
                        case 5:
                            _c.sent();
                            _c.label = 6;
                        case 6: return [2 /*return*/];
                    }
                });
            });
        }
        var fetchParams, response, name, error_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!(0, handler_input_1.isFileBasedHandlerInput)(handlerInput)) {
                        throw new Error('loadCsvData can be only used with FileBasedHandlerInput.');
                    }
                    fetchParams = getFetchParams(url, options);
                    return [4 /*yield*/, networkAdapter.fetch(fetchParams.urlWithQuery, fetchParams.options)];
                case 1:
                    response = _a.sent();
                    if (!response.ok || response.body === null) {
                        throw new Error("loadCsvData: unexpected response. [status]: ".concat(response.status, ", [statusText]: ").concat(response.statusText));
                    }
                    name = handlerInput.name;
                    _a.label = 2;
                case 2:
                    _a.trys.push([2, 4, , 5]);
                    return [4 /*yield*/, ingestStreamData(tempDataManager, response.body, streamToFile, name)];
                case 3:
                    _a.sent();
                    return [3 /*break*/, 5];
                case 4:
                    error_1 = _a.sent();
                    throw new Error("ingestData: Data Injestion into epsTempData directory failed.\n" + error_1);
                case 5: return [2 /*return*/];
            }
        });
    });
}
exports.loadCsvData = loadCsvData;
function loadData(handlerInput, tempDataManager, networkAdapter, url, options) {
    return __awaiter(this, void 0, void 0, function () {
        function streamToFile(stream, filePath) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, streamPipeline(stream, fs_1.default.createWriteStream(filePath, { flags: 'a' }))];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        }
        var fetchParams, response, name, error_2;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!(0, handler_input_1.isFileBasedHandlerInput)(handlerInput)) {
                        throw new Error('loadData can be only used with FileBasedHandlerInput.');
                    }
                    fetchParams = getFetchParams(url, options);
                    return [4 /*yield*/, networkAdapter.fetch(fetchParams.urlWithQuery, fetchParams.options)];
                case 1:
                    response = _a.sent();
                    if (!response.ok || response.body === null) {
                        throw new Error("loadData: unexpected response. [status]: ".concat(response.status, ", [statusText]: ").concat(response.statusText));
                    }
                    name = handlerInput.name;
                    _a.label = 2;
                case 2:
                    _a.trys.push([2, 4, , 5]);
                    return [4 /*yield*/, ingestStreamData(tempDataManager, response.body, streamToFile, name)];
                case 3:
                    _a.sent();
                    return [3 /*break*/, 5];
                case 4:
                    error_2 = _a.sent();
                    throw new Error("ingestData: Data Injestion into epsTempData directory failed.\n" + error_2);
                case 5: return [2 /*return*/];
            }
        });
    });
}
exports.loadData = loadData;
function loadParquetData(handlerInput, tempDataManager, networkAdapter, tableFileCounter, url, options) {
    var _a;
    return __awaiter(this, void 0, void 0, function () {
        function streamToFile(stream, filePath) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, streamPipeline(stream, fs_1.default.createWriteStream(filePath, { flags: 'a' }))];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        }
        var fetchParams, response, name, extractorId, dirPath, index, filePath, error_3;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (!(0, handler_input_1.isFileBasedHandlerInput)(handlerInput)) {
                        throw new Error('loadParquetData can be only used with FileBasedHandlerInput.');
                    }
                    fetchParams = getFetchParams(url, options);
                    return [4 /*yield*/, networkAdapter.fetch(fetchParams.urlWithQuery, fetchParams.options)];
                case 1:
                    response = _b.sent();
                    if (!response.ok || response.body === null) {
                        throw new Error("loadParquetData: unexpected response. [status]: ".concat(response.status, ", [statusText]: ").concat(response.statusText));
                    }
                    name = handlerInput.name;
                    _b.label = 2;
                case 2:
                    _b.trys.push([2, 4, , 5]);
                    extractorId = extractor_cache_1.default.context.extractorId;
                    tempDataManager.createTempDataDirIfNotExists(extractorId);
                    dirPath = tempDataManager.getTempDataDirPath(extractorId, name);
                    // create parquet data dir if it does not exist
                    if (!fs_1.default.existsSync(dirPath)) {
                        fs_1.default.mkdirSync(dirPath, { recursive: true });
                        eps_logger_1.Logger.info("Temporary parquet data directory created: ".concat(dirPath));
                    }
                    index = (_a = tableFileCounter[name]) !== null && _a !== void 0 ? _a : 0;
                    tableFileCounter[name] = index + 1;
                    filePath = node_path_1.default.join(dirPath, "f-".concat(index, ".parquet"));
                    // Duckdb read APIs can only support filepaths less than 255 characters in length.
                    if (filePath.length >= 255) {
                        throw new Error("Temporary data filepath has to be less than 255 characters in length. tempDataFilePath: ".concat(filePath));
                    }
                    return [4 /*yield*/, streamToFile(response.body, filePath)];
                case 3:
                    _b.sent();
                    return [3 /*break*/, 5];
                case 4:
                    error_3 = _b.sent();
                    throw new Error("ingestData: Data Injestion into epsTempData directory failed.\n" + error_3);
                case 5: return [2 /*return*/];
            }
        });
    });
}
exports.loadParquetData = loadParquetData;
function ingestStreamData(tempDataManager, stream, streamToFile, filename) {
    return __awaiter(this, void 0, void 0, function () {
        var extractorId, filePath;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    extractorId = extractor_cache_1.default.context.extractorId;
                    tempDataManager.createTempDataDirIfNotExists(extractorId);
                    filePath = tempDataManager.getTempDataFilePath(extractorId, filename);
                    return [4 /*yield*/, streamToFile(stream, filePath)];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
/**
 * Using HandlerInput for now because we are getting HandlerInput via sandbox during runtime, and the type is HandlerInput.
 * When we export the API from SDK we should use FileBasedHandlerInput instead.
 */
function ingestDataRows(handlerInput, tempDataManager, rows) {
    return __awaiter(this, void 0, void 0, function () {
        var extractorId, name, filePath;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!(0, handler_input_1.isFileBasedHandlerInput)(handlerInput)) {
                        throw new Error('ingestDataRows can be only used with FileBasedHandlerInput.');
                    }
                    extractorId = extractor_cache_1.default.context.extractorId;
                    name = handlerInput.name;
                    tempDataManager.createTempDataDirIfNotExists(extractorId);
                    filePath = tempDataManager.getTempDataFilePath(extractorId, name);
                    return [4 /*yield*/, writeCSVToFile(rows, filePath)];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    });
}
exports.ingestDataRows = ingestDataRows;
/**
 * Appends data to a CSV file identified by the file path.
 * The function uses the first DataRow object's keys order to determine the data column ordering.
 * When calling the function multiple times, the caller is responsible for maintaining the column ordering alignment.
 * The function uses the name property in the DataRow object to identify a table.
 * Rows will be appended to the same file if the file path is the same.
 * The header is only written on the first call.
 *
 * @param dataRows - An array of DataRow objects containing the data to be appended.
 * @param filePath - The file path of the CSV file to append data to.
 * @returns A Promise that resolves when the data has been appended to the file.
 */
function writeCSVToFile(dataRows, filePath) {
    return new Promise(function (resolve, reject) {
        var writeHeader = true;
        // Only write header once, so if the file already exists and has a header,
        // then we don't need to write the header again.
        if (fs_1.default.existsSync(filePath)) {
            writeHeader = false;
        }
        var outputStream = fs_1.default.createWriteStream(filePath, { flags: 'a' });
        // if dataRows is empty, close the stream with an empty file
        if (dataRows.length === 0) {
            outputStream.close();
            resolve();
            return;
        }
        try {
            (0, csv_stringify_1.stringify)(dataRows, {
                header: writeHeader,
                columns: Object.keys(dataRows[0]),
                // using cast as csv-stringify converts boolean values to 0 or 1
                cast: {
                    boolean: function (value) { return value.toString(); },
                },
            }).pipe(outputStream);
        }
        catch (error) {
            error.message = "ingestDataRows: ingestDataRows failed.\n".concat(error.message);
            reject(error);
        }
        outputStream.on('error', function (err) {
            eps_logger_1.Logger.error('Error during ingestDataRows.' + err);
            reject(err);
        });
        outputStream.on('finish', function () {
            eps_logger_1.Logger.info("Count of rows ingested: ".concat(dataRows.length));
            resolve();
        });
    });
}
var FirstLineTransform = /** @class */ (function (_super) {
    __extends(FirstLineTransform, _super);
    function FirstLineTransform() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._firstChunk = true;
        return _this;
    }
    FirstLineTransform.prototype._transform = function (chunk, encoding, callback) {
        if (this._firstChunk) {
            var firstLineEnd = chunk.indexOf('\n');
            if (firstLineEnd > -1) {
                chunk = chunk.slice(firstLineEnd + 1);
                this._firstChunk = false;
            }
            else {
                chunk = null;
            }
        }
        callback(null, chunk);
    };
    return FirstLineTransform;
}(node_stream_1.Transform));
function getFetchParams(urlString, options) {
    var _a;
    if (options === undefined) {
        return { urlWithQuery: urlString, options: { method: 'GET' } };
    }
    var method = (_a = options === null || options === void 0 ? void 0 : options.method) !== null && _a !== void 0 ? _a : 'GET';
    if (method !== 'GET' && method !== 'POST') {
        throw new Error("'method' must be 'GET' or 'POST'. Unsupported method: ".concat(method));
    }
    var url = new URL(urlString);
    if (options.query) {
        Object.entries(options.query).forEach(function (_a) {
            var _b = __read(_a, 2), key = _b[0], value = _b[1];
            if (value === undefined) {
                return;
            }
            url.searchParams.append(key, (0, type_utils_1.stringifyUnknown)(value));
        });
    }
    var headers = options.headers, body = options.body;
    var fetchOption = (0, request_utils_1.composeFetchOption)(method, headers, body);
    return { urlWithQuery: url.toString(), options: fetchOption };
}
exports.getFetchParams = getFetchParams;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmV0Y2gtdXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvZXBzL3NhbmRib3gvc2RrL2ZldGNoZXItdXRpbHMvZmV0Y2gtdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLCtDQUF5QztBQUN6QywwQ0FBbUI7QUFDbkIsd0RBQTRCO0FBQzVCLDJDQUFvRTtBQUNwRSx1Q0FBcUM7QUFHckMsNERBQWdFO0FBRWhFLHdFQUE4RjtBQUU5RixrRUFBdUU7QUFDdkUsdUZBQStEO0FBQy9ELDBEQUFvRDtBQUdwRCwwREFBd0Q7QUFDeEQsOERBQWlFO0FBQ2pFLG9EQUE2RDtBQUU3RCwrRUFBK0U7QUFDL0UsSUFBTSxjQUFjLEdBQUcsSUFBQSxxQkFBUyxFQUFDLHNCQUFRLENBQUMsQ0FBQTtBQWtEMUM7SUFBOEMsb0NBQWE7SUFBM0Q7O0lBMENBLENBQUM7SUF6Q0MsK0JBQUksR0FBSjtRQUNFLElBQU0sT0FBTyxHQUFpQjtZQUM1QjtnQkFDRSxRQUFRLEVBQUUsSUFBSTtnQkFDZCxZQUFZLEVBQUUsV0FBVztnQkFDekIsV0FBVyxFQUFFLGVBQWUsQ0FBQyxJQUFJLENBQUM7YUFDbkM7WUFDRDtnQkFDRSxRQUFRLEVBQUUsSUFBSTtnQkFDZCxZQUFZLEVBQUUsa0JBQWtCO2dCQUNoQyxXQUFXLEVBQUUsc0JBQXNCLENBQUMsSUFBSSxDQUFDO2FBQzFDO1lBQ0Q7Z0JBQ0UsUUFBUSxFQUFFLElBQUk7Z0JBQ2QsWUFBWSxFQUFFLFVBQVU7Z0JBQ3hCLFdBQVcsRUFBRSxjQUFjLENBQUMsSUFBSSxDQUFDO2FBQ2xDO1lBQ0Q7Z0JBQ0UsUUFBUSxFQUFFLElBQUk7Z0JBQ2QsWUFBWSxFQUFFLGVBQWU7Z0JBQzdCLFdBQVcsRUFBRSxtQkFBbUIsQ0FBQyxJQUFJLENBQUM7YUFD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