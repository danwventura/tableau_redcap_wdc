import { ColumnHeader } from '../../shared/types/column-header';
import { DataRow } from '../../shared/types/data-row';
/**
 * Convert array type data into key-value pair DataRow array.
 *
 * The function uses array index to align data and column name.
 */
export declare function composeDataRows(rows: string[][], columnNames: string[]): DataRow[];
/**
 * Convert array type data into key-value pair DataRow array with column metadata.
 * The function uses array index to align data and column name.
 *
 * The result will only contain the columns that exists in the columnMetadata.
 * The data values will be converted into into corresponding type based on columnMetadata.
 *
 *   - rows and columnNames determine the alignment and the order
 *   - columnMetadata determines the selected column and the data value type
 */
export declare function composeDataRowsWithType(rows: string[][], columnNames: string[], columnMetadata: Map<string, ColumnHeader>): DataRow[];
/**
 * Determines if an array of records is a valid array of DataRow.
 * We are assuming here that the rows object is non-empty.
 *
 * @param {Record<string, unknown>[]} rows - The array of records to check.
 *
 * @returns {boolean} - A boolean indicating whether the array is a valid array of data rows.
 */
export declare function isValidDataRows(rows: Record<string, unknown>[]): rows is DataRow[];
/**
 * Composes an array of data rows with typed values from an array of objects.
 * We are assuming here that the rows object is non-empty.
 *
 * @param {Record<string, unknown>[]} rows - The array of objects to use as a source of values.
 * @param {Map<string, ColumnHeader>} columnMetadata - A map of column headers that describes the expected types for each column.
 *
 * @returns {DataRow[]} - An array of data rows with typed values.
 *
 * @throws {Error} - If any columns are missing from the input array of objects.
 */
export declare function composeDataRowsWithTypeFromObjectArray(rows: Record<string, string>[], columnMetadata: Map<string, ColumnHeader>): DataRow[];
/**
 * Using a read stream is likely the most performant method for very large files,
 * since it reads only the first chunk of data from the file and does not retrieve the file size.
 */
export declare function isFileEmpty(filepath: string): Promise<boolean>;
