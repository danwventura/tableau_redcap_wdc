"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.waitForExtractorMessage = exports.handleExtract = exports.validateConnectionData = void 0;
var http_status_codes_1 = require("http-status-codes");
var node_path_1 = __importDefault(require("node:path"));
var uuid_1 = require("uuid");
var eps_error_1 = require("../../../types/eps-error");
var eps_error_info_1 = require("../../../types/eps-error-info");
var connector_launch_status_1 = require("../../../../shared/enums/connector-launch-status");
var extractor_type_1 = require("../../../../shared/enums/extractor-type");
var error_codes_1 = require("../../../../shared/errors/error-codes");
var error_source_1 = require("../../../../shared/errors/error-source");
var status_code_1 = require("../../../../shared/errors/status-code");
var extractor_status_1 = require("../../../types/extractor-status");
var eps_logger_1 = require("../../../logging/eps-logger");
var process_manager_1 = require("../../components/process-manager");
var app_global_1 = __importDefault(require("../../core/app-global"));
var eps_process_types_1 = require("../../../types/eps-process-types");
var extractor_message_1 = require("../../../types/extractor-message");
var handler_utils_1 = require("./handler-utils");
var HYPER_FETCHER = 'hyper-fetcher';
var EXTRACTOR_APP_PATH = node_path_1.default.resolve(__dirname, '../../../extractor/extractor-app.js');
var isHyperExtractor = function (handlerInputs) { return handlerInputs.some(function (x) { return x.fetcher === HYPER_FETCHER; }); };
var isNotHyperExtractor = function (handlerInputs) { return handlerInputs.some(function (x) { return x.fetcher !== HYPER_FETCHER; }); };
function validateConnectionData(body) {
    if (!body || typeof body !== 'object' || Object.keys(body).length === 0) {
        var message = 'Bad Request: Request body is empty or not JSON; request body must have ConnectionData.';
        eps_logger_1.Logger.logEPSError(status_code_1.StatusCode.FailedPrecondition, error_source_1.ErrorSources.Client, error_codes_1.ErrorCodes.M92GXFQP, message);
        throw Error(message);
    }
    // Check there are some handlerInputs
    var handlerInputs = body.handlerInputs;
    if (!handlerInputs || !Array.isArray(handlerInputs) || handlerInputs.length === 0) {
        var errorMessage = 'Bad Request: handlerInputs must be provided in request body.';
        eps_logger_1.Logger.logEPSError(status_code_1.StatusCode.FailedPrecondition, error_source_1.ErrorSources.Configuration, error_codes_1.ErrorCodes.ENT97JSH, errorMessage);
        throw new eps_error_1.EPSError(errorMessage, new eps_error_info_1.EPSErrorInfo(handler_utils_1.ERROR_CODE_BAD_TACO), connector_launch_status_1.ConnectorLaunchStatus.BadTaco);
    }
    // Check hyper fetcher and eps fetcher are not in same request, which is currently not supported
    if (isHyperExtractor(handlerInputs) && isNotHyperExtractor(handlerInputs)) {
        var error = new Error("You cannot mix ".concat(HYPER_FETCHER, " with non-").concat(HYPER_FETCHER, " in the same request."));
        eps_logger_1.Logger.error(error);
        throw error;
    }
}
exports.validateConnectionData = validateConnectionData;
// TODO: figure out if it is used. If not, remove this!
function handleHyperExtractor(extractorLaunchedEvent, extractHandlerRequest) {
    var extractorType = extractor_type_1.ExtractorType.hyper;
    var connectionId = extractHandlerRequest.connectionId, connectionData = extractHandlerRequest.connectionData, secrets = extractHandlerRequest.secrets;
    var extractorLaunchSuccessOptions = {
        type: 'success',
        extractorType: extractorType,
        connectionData: connectionData,
        secrets: secrets,
    };
    extractorLaunchedEvent.emit((0, handler_utils_1.getExtractorLaunchedConnectionId)(connectionId), extractorLaunchSuccessOptions);
    return {
        response: { status: connector_launch_status_1.ConnectorLaunchStatus.Extract, extractorType: extractorType, connectionData: connectionData, secrets: secrets },
        httpStatusCode: http_status_codes_1.StatusCodes.OK,
    };
}
function handleEpsExtractor(extractorLaunchedEvent, extractHandlerRequest) {
    return __awaiter(this, void 0, void 0, function () {
        var connectionId, secrets, connectionData, extractorMessage, extractorType, extractorLaunchSuccessOptions, extractApiResponse, errorMessage;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    connectionId = extractHandlerRequest.connectionId, secrets = extractHandlerRequest.secrets, connectionData = extractHandlerRequest.connectionData;
                    return [4 /*yield*/, launchEpsExtractor(extractHandlerRequest)];
                case 1:
                    extractorMessage = _a.sent();
                    extractorType = extractor_type_1.ExtractorType.eps;
                    extractorLaunchSuccessOptions = {
                        type: 'success',
                        extractorType: extractorType,
                        extractorMessage: extractorMessage,
                        connectionData: connectionData,
                        secrets: secrets,
                    };
                    extractorLaunchedEvent.emit((0, handler_utils_1.getExtractorLaunchedConnectionId)(connectionId), extractorLaunchSuccessOptions);
                    extractApiResponse = {
                        status: connector_launch_status_1.ConnectorLaunchStatus.Extract,
                        extractorType: extractorType,
                        port: extractorMessage.port,
                        extractorId: extractorMessage.extractorId,
                    };
                    errorMessage = extractorMessage.errorMessage;
                    if (errorMessage) {
                        extractApiResponse.status = connector_launch_status_1.ConnectorLaunchStatus.Error;
                        extractApiResponse.errorMessage = errorMessage;
                    }
                    return [2 /*return*/, {
                            httpStatusCode: http_status_codes_1.StatusCodes.OK,
                            response: extractApiResponse,
                        }];
            }
        });
    });
}
function handleExtract(extractorLaunchedEvent, extractHandlerRequest) {
    return __awaiter(this, void 0, void 0, function () {
        var connectionId, connectionData, error_1, options;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    connectionId = extractHandlerRequest.connectionId, connectionData = extractHandlerRequest.connectionData;
                    // Done with browser, mark completed to declare it was completed properly.
                    app_global_1.default.connectionManager.setIsSubmitted(connectionId, true);
                    if (isHyperExtractor(connectionData.handlerInputs)) {
                        return [2 /*return*/, handleHyperExtractor(extractorLaunchedEvent, extractHandlerRequest)];
                    }
                    _a.label = 1;
                case 1:
                    _a.trys.push([1, 3, , 4]);
                    return [4 /*yield*/, handleEpsExtractor(extractorLaunchedEvent, extractHandlerRequest)];
                case 2: return [2 /*return*/, _a.sent()];
                case 3:
                    error_1 = _a.sent();
                    options = {
                        type: 'failure',
                        error: error_1,
                        connectorLaunchStatus: connector_launch_status_1.ConnectorLaunchStatus.BadTaco,
                    };
                    extractorLaunchedEvent.emit((0, handler_utils_1.getExtractorLaunchedConnectionId)(connectionId), options);
                    return [2 /*return*/, {
                            httpStatusCode: http_status_codes_1.StatusCodes.OK,
                            response: new eps_error_1.EPSError(error_1, new eps_error_info_1.EPSErrorInfo(handler_utils_1.ERROR_CODE_BAD_TACO), connector_launch_status_1.ConnectorLaunchStatus.BadTaco),
                        }];
                case 4: return [2 /*return*/];
            }
        });
    });
}
exports.handleExtract = handleExtract;
function launchEpsExtractor(extractHandlerRequest) {
    return __awaiter(this, void 0, void 0, function () {
        var tacoPath, connectionId, connectorClass, connectionData, secrets, distinctConnectorName, handlersDir, permission, extractorOptions, portConfig, extractorId, extractorProcess, extractorMessage;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    tacoPath = extractHandlerRequest.tacoPath, connectionId = extractHandlerRequest.connectionId, connectorClass = extractHandlerRequest.connectorClass, connectionData = extractHandlerRequest.connectionData, secrets = extractHandlerRequest.secrets;
                    return [4 /*yield*/, (0, handler_utils_1.getOrInitializeDistinctConnectorName)({
                            connectionId: connectionId,
                            connectorClass: connectorClass,
                            tacoPath: tacoPath,
                        })];
                case 1:
                    distinctConnectorName = _a.sent();
                    if (app_global_1.default.connectionManager.hasActiveConnection(connectionId)) {
                        // With ExtractorHandler, this should never be hit. Keep it here for a sanity check to avoid creating an orphan extractor process.
                        throw new Error("There is already a live extractor for ConnectionId '".concat(connectionId, "'."));
                    }
                    handlersDir = app_global_1.default.tacoInitializer.getConnectorHandlersPath(distinctConnectorName);
                    permission = app_global_1.default.tacoInitializer.getConnectorConfig(distinctConnectorName).permission;
                    extractorOptions = {
                        handlersDir: handlersDir,
                        connectorClass: connectorClass,
                        connectionId: connectionId,
                        handlerInputs: connectionData.handlerInputs,
                        secrets: secrets,
                        permission: permission,
                    };
                    portConfig = {
                        portRange: app_global_1.default.portManager.getPortRange(),
                        reservedPorts: app_global_1.default.portManager.getReservedPorts(),
                    };
                    extractorId = (0, uuid_1.v4)();
                    extractorProcess = app_global_1.default.processManager.fork(eps_process_types_1.EPSProcessName.EPSExtractor, process_manager_1.ProcessType.child, EXTRACTOR_APP_PATH, [
                        extractorId,
                        // TOOD: nodejs has size limit on param length. We need to handle it better.
                        JSON.stringify(extractorOptions),
                        JSON.stringify(portConfig),
                    ]);
                    return [4 /*yield*/, waitForExtractorMessage(extractorProcess)];
                case 2:
                    extractorMessage = _a.sent();
                    if ((0, extractor_message_1.isSchemaDoneExtractorMessage)(extractorMessage)) {
                        app_global_1.default.connectionManager.addExtractorProcess(connectionId, extractorProcess, extractorId);
                    }
                    return [2 /*return*/, extractorMessage];
            }
        });
    });
}
/**
 * Wait for the extractor process to send the message to EPS.
 * The function will settle the promise on the first (known) message sent from extractor.
 */
function waitForExtractorMessage(extractorProcess) {
    var schemaDone = false;
    return new Promise(function (resolve, reject) {
        var _a, _b;
        (_a = extractorProcess.stdout) === null || _a === void 0 ? void 0 : _a.on('data', function (data) {
            eps_logger_1.Logger.info("Extractor (pid:".concat(extractorProcess.pid, ") stdout: ").concat(data));
        });
        (_b = extractorProcess.stderr) === null || _b === void 0 ? void 0 : _b.on('data', function (data) {
            eps_logger_1.Logger.error("Extractor (pid:".concat(extractorProcess.pid, ") stderr: ").concat(data));
        });
        extractorProcess.on('message', function (message) {
            var status = message.status;
            if (status === extractor_status_1.ExtractorStatus.SchemaDone) {
                schemaDone = true;
                resolve(message);
            }
            else if (status === extractor_status_1.ExtractorStatus.ExtractorError) {
                var errMsg = "Extractor (pid:".concat(extractorProcess.pid, ") reported an error: ").concat(message.errorMessage);
                eps_logger_1.Logger.logEPSError(status_code_1.StatusCode.Cancelled, error_source_1.ErrorSources.Client, error_codes_1.ErrorCodes.HU3H87WB, errMsg);
                reject(errMsg);
            }
            else {
                // All messages from extractor should be sent by sendExtractorMessage(), so based on the code,
                // this line should never be hit. Just logging here in case anything is missed.
                eps_logger_1.Logger.debug(message);
            }
        });
        extractorProcess.on('error', function (err) {
            // ERR_IPC_CHANNEL_CLOSED is raised when parent is closing and is ignorable in that case.
            var errMsg = "Extractor (pid:".concat(extractorProcess.pid, ") emitted an error event: ").concat(err, ".");
            eps_logger_1.Logger.logEPSError(status_code_1.StatusCode.Cancelled, error_source_1.ErrorSources.Client, error_codes_1.ErrorCodes.PSZECVJ1, errMsg);
            reject(errMsg);
        });
        extractorProcess.on('disconnect', function () {
            if (!schemaDone) {
                var errMsg = "Extractor (pid:".concat(extractorProcess.pid, ") disconnected before extractor completes. Check logs for more details.");
                reject(errMsg);
            }
            // When schemaDone is true, the promise is already settled.
            // Log here for extractor process status.
            eps_logger_1.Logger.info("Extractor (pid:".concat(extractorProcess.pid, ") disconnected."));
        });
        extractorProcess.on('exit', function (code, signal) {
            if (!schemaDone) {
                var errMsg = "Extractor (pid:".concat(extractorProcess.pid, ") exited before extractor completes. Check logs for more details.");
                reject(errMsg);
            }
            // When schemaDone is true, the promise is already settled.
            // Log here for extractor process status.
            eps_logger_1.Logger.info("Extractor (pid:".concat(extractorProcess.pid, ") exited with code ").concat(code, " on signal '").concat(signal, "'."));
        });
        extractorProcess.on('close', function (code, signal) {
            if (!schemaDone) {
                var errMsg = "Extractor (pid:".concat(extractorProcess.pid, ") closed before extractor completes. Check logs for more details.");
                reject(errMsg);
            }
            // When schemaDone is true, the promise is already settled.
            // Log here for extractor process status.
            eps_logger_1.Logger.info("Extractor (pid:".concat(extractorProcess.pid, ") closed with code ").concat(code, " on signal '").concat(signal, "'."));
        });
    });
}
exports.waitForExtractorMessage = waitForExtractorMessage;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXh0cmFjdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9lcHMvbWFpbi9hcGkvZXBzLWhhbmRsZXJzL2V4dHJhY3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsdURBQStDO0FBRy9DLHdEQUE0QjtBQUM1Qiw2QkFBbUM7QUFFbkMsc0RBQW1EO0FBQ25ELGdFQUE0RDtBQUM1RCw0RkFBd0Y7QUFDeEYsMEVBQXVFO0FBQ3ZFLHFFQUFrRTtBQUNsRSx1RUFBcUU7QUFDckUscUVBQWtFO0FBQ2xFLG9FQUFpRTtBQUlqRSwwREFBb0Q7QUFDcEQsb0VBQThEO0FBQzlELHFFQUE2QztBQUM3QyxzRUFBaUU7QUFHakUsc0VBSXlDO0FBRXpDLGlEQUl3QjtBQUV4QixJQUFNLGFBQWEsR0FBRyxlQUFlLENBQUE7QUFFckMsSUFBTSxrQkFBa0IsR0FBRyxtQkFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUUscUNBQXFDLENBQUMsQ0FBQTtBQWV6RixJQUFNLGdCQUFnQixHQUFHLFVBQUMsYUFBNkIsSUFBSyxPQUFBLGFBQWEsQ0FBQyxJQUFJLENBQUMsVUFBQyxDQUFDLElBQUssT0FBQSxDQUFDLENBQUMsT0FBTyxLQUFLLGFBQWEsRUFBM0IsQ0FBMkIsQ0FBQyxFQUF0RCxDQUFzRCxDQUFBO0FBQ2xILElBQU0sbUJBQW1CLEdBQUcsVUFBQyxhQUE2QixJQUFLLE9BQUEsYUFBYSxDQUFDLElBQUksQ0FBQyxVQUFDLENBQUMsSUFBSyxPQUFBLENBQUMsQ0FBQyxPQUFPLEtBQUssYUFBYSxFQUEzQixDQUEyQixDQUFDLEVBQXRELENBQXNELENBQUE7QUFFckgsU0FBZ0Isc0JBQXNCLENBQUMsSUFBYTtJQUNsRCxJQUFJLENBQUMsSUFBSSxJQUFJLE9BQU8sSUFBSSxLQUFLLFFBQVEsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FB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