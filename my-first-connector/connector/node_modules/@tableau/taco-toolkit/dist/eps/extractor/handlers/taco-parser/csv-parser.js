"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CsvTacoParser = void 0;
var parseCSV = __importStar(require("csv-parse"));
var fs_1 = __importDefault(require("fs"));
var papaparse_1 = __importDefault(require("papaparse"));
var readline = __importStar(require("readline"));
var column_header_property_1 = require("../../../../shared/enums/column-header-property");
var parse_utils_1 = require("../../../utils/parse-utils");
var eps_logger_1 = require("./../../../logging/eps-logger");
var base_taco_file_parser_1 = require("./base-taco-file-parser");
// csv-parse lib is 1-based indexing
var FIRST_DATA_ROW_INDEX = 2;
var DEFAULT_DELIMITER = ',';
var CsvTacoParser = /** @class */ (function (_super) {
    __extends(CsvTacoParser, _super);
    function CsvTacoParser(tempDataManager, extractorId, filename) {
        var _this = _super.call(this) || this;
        _this.tempDataManager = tempDataManager;
        _this.extractorId = extractorId;
        _this.filename = filename;
        _this.index = FIRST_DATA_ROW_INDEX;
        _this.hasMoreRows = true;
        _this.filepath = _this.tempDataManager.getTempDataFilePath(_this.extractorId, _this.filename);
        return _this;
    }
    /**
     * Get ColumnHeaders for a CSV file.
     *
     * By default, it returns all column header fields and all columns are typed as string.
     * If columns metadata is set by setColumnHeaders, it will filter the columns with the given columnHeaders,
     * while the column order from the file is still preserved.
     */
    CsvTacoParser.prototype.getColumnHeaders = function () {
        return __awaiter(this, void 0, void 0, function () {
            var columnNames, columnHeaders, columnNames_1, columnNames_1_1, columnName, columnHeader;
            var e_1, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.getColumnNamesFromFile()
                        // empty file
                    ];
                    case 1:
                        columnNames = _b.sent();
                        // empty file
                        if (columnNames.length === 0) {
                            if (!this.columnHeaderMap) {
                                throw new Error('Failed to find column headers from ingested data. If the table empty, ' +
                                    'column headers must be provided via DataContainer.');
                            }
                            return [2 /*return*/, Array.from(this.columnHeaderMap.values())];
                        }
                        // when columnHeaderMap is NOT present, all columns are selected as string type
                        if (!this.columnHeaderMap) {
                            return [2 /*return*/, columnNames.map(function (columnName) {
                                    return { id: columnName, dataType: column_header_property_1.DataType.String };
                                })];
                        }
                        columnHeaders = [];
                        try {
                            for (columnNames_1 = __values(columnNames), columnNames_1_1 = columnNames_1.next(); !columnNames_1_1.done; columnNames_1_1 = columnNames_1.next()) {
                                columnName = columnNames_1_1.value;
                                columnHeader = this.columnHeaderMap.get(columnName);
                                if (columnHeader) {
                                    columnHeaders.push(columnHeader);
                                }
                            }
                        }
                        catch (e_1_1) { e_1 = { error: e_1_1 }; }
                        finally {
                            try {
                                if (columnNames_1_1 && !columnNames_1_1.done && (_a = columnNames_1.return)) _a.call(columnNames_1);
                            }
                            finally { if (e_1) throw e_1.error; }
                        }
                        return [2 /*return*/, columnHeaders];
                }
            });
        });
    };
    /**
     * Set columns metadata info to the parser. When columnHeaders are set, getColumnHeaders will
     * respect the given info. Otherwise, all fields are assumed as string type.
     *
     * To prevent the method from being misused, this method can be called once, otherwise,
     * it throws an error.
     */
    CsvTacoParser.prototype.setColumnHeaders = function (columnHeaders) {
        var e_2, _a;
        if (this.columnHeaderMap) {
            throw new Error('columnHeaders can be only set once.');
        }
        this.columnHeaderMap = new Map();
        try {
            for (var columnHeaders_1 = __values(columnHeaders), columnHeaders_1_1 = columnHeaders_1.next(); !columnHeaders_1_1.done; columnHeaders_1_1 = columnHeaders_1.next()) {
                var columnHeader = columnHeaders_1_1.value;
                var id = columnHeader.id;
                if (this.columnHeaderMap.has(id)) {
                    throw new Error("Column name must be unique. Found duplicate column name '".concat(id, "'"));
                }
                this.columnHeaderMap.set(id, columnHeader);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (columnHeaders_1_1 && !columnHeaders_1_1.done && (_a = columnHeaders_1.return)) _a.call(columnHeaders_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    CsvTacoParser.prototype.hasNextRow = function () {
        return this.hasMoreRows;
    };
    CsvTacoParser.prototype.resetIndex = function () {
        this.index = FIRST_DATA_ROW_INDEX;
    };
    CsvTacoParser.prototype.getIndex = function () {
        return this.index;
    };
    CsvTacoParser.prototype.getDelimiter = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.delimiter === undefined)) return [3 /*break*/, 2];
                        // parse out delimiter from header
                        return [4 /*yield*/, this.getColumnNamesFromFile()];
                    case 1:
                        // parse out delimiter from header
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/, this.delimiter];
                }
            });
        });
    };
    CsvTacoParser.prototype.getNextDataRows = function (count) {
        return __awaiter(this, void 0, void 0, function () {
            var columnNames, delimiter, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (count < 1) {
                            throw new Error("CsvTacoParser.getNextDataRows(): count value ".concat(count, " should be greater than 0."));
                        }
                        return [4 /*yield*/, this.getColumnNamesFromFile()
                            // empty file
                        ];
                    case 1:
                        columnNames = _a.sent();
                        // empty file
                        if (columnNames.length === 0) {
                            if (!this.columnHeaderMap) {
                                throw new Error('Failed to find column headers from ingested data. If the table empty, ' +
                                    'column headers must be provided via DataContainer.');
                            }
                            // if columnHeaders is provided, it is valid empty table.
                            this.hasMoreRows = false;
                            return [2 /*return*/, []];
                        }
                        return [4 /*yield*/, this.getDelimiter()
                            // We are intentionally trying to get one extra record, to calculate "hasMoreRows"
                        ];
                    case 2:
                        delimiter = _a.sent();
                        return [4 /*yield*/, parseCsvFile(this.filepath, this.index, count + 1, delimiter)];
                    case 3:
                        data = _a.sent();
                        this.index += count;
                        if (data.length > count) {
                            this.hasMoreRows = true;
                            data.pop();
                        }
                        else {
                            this.hasMoreRows = false;
                        }
                        if (this.columnHeaderMap) {
                            return [2 /*return*/, (0, parse_utils_1.composeDataRowsWithType)(data, columnNames, this.columnHeaderMap)];
                        }
                        return [2 /*return*/, (0, parse_utils_1.composeDataRows)(data, columnNames)];
                }
            });
        });
    };
    CsvTacoParser.prototype.getColumnNamesFromFile = function () {
        return __awaiter(this, void 0, void 0, function () {
            var headerString, result, _a, delimiter, fields;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (this.headersFromFile && this.headersFromFile.length > 0) {
                            return [2 /*return*/, this.headersFromFile];
                        }
                        /*
                        papa-parse library does a better job in auto-detecting csv delimiter,
                        we are using this lib to get the delimiter from the header row and
                        use it to parse the rest of the file
                        */
                        if (!fs_1.default.existsSync(this.filepath)) {
                            throw new Error("CsvTacoParser.getColumnNamesFromFile(): File does not exist." +
                                "Check the logs in case of any error during data ingestion." +
                                "If the source table is empty, consider using FetchUtils.ingestDataRows API.");
                        }
                        return [4 /*yield*/, getHeaderFromFile(this.filepath)];
                    case 1:
                        headerString = _b.sent();
                        result = papaparse_1.default.parse(headerString, { header: true });
                        _a = result.meta, delimiter = _a.delimiter, fields = _a.fields;
                        if (fields) {
                            this.delimiter = delimiter;
                            this.headersFromFile = fields;
                        }
                        else {
                            this.delimiter = DEFAULT_DELIMITER; // ','
                            this.headersFromFile = [];
                        }
                        return [2 /*return*/, this.headersFromFile];
                }
            });
        });
    };
    // TO DO : Update this method when we implement csv parsing using duckdb
    CsvTacoParser.prototype.getRowCount = function () {
        return Promise.resolve(-1);
    };
    return CsvTacoParser;
}(base_taco_file_parser_1.TacoFileParser));
exports.CsvTacoParser = CsvTacoParser;
function parseCsvFile(filepath, start, count, delimiter) {
    return new Promise(function (resolve, reject) {
        var from = start;
        var to = from + count - 1;
        var rows = [];
        fs_1.default.createReadStream(filepath)
            .pipe(parseCSV.parse({
            delimiter: delimiter,
            from_line: from,
            to_line: to,
            skip_empty_lines: true,
        }))
            .on('data', function (row) {
            rows.push(row);
        })
            .on('end', function () {
            resolve(rows);
        })
            .on('error', function (error) {
            eps_logger_1.Logger.error(error);
            reject(error);
        });
    });
}
/**
 * Get column headers (first line) from the file.
 *
 * If the file does NOT exist, we assume that errors occurred during ingestion,
 * so the function rejects.
 * If the connector has empty table, it should explicitly ingest an empty DataRow[].
 */
function getHeaderFromFile(filepath) {
    return new Promise(function (resolve, reject) {
        var firstLine = '';
        // Create a readline interface for the file
        var rl = readline.createInterface({
            input: fs_1.default.createReadStream(filepath),
            crlfDelay: Infinity,
        });
        // Listen for the 'line' event, which is emitted each time a line is read
        rl.on('line', function (line) {
            firstLine = line;
            // Close the readline interface after the first line is read
            rl.close();
        });
        rl.on('close', function () {
            eps_logger_1.Logger.info("First line of CSV file: ".concat(firstLine));
            resolve(firstLine);
        });
        rl.on('error', function (error) {
            eps_logger_1.Logger.error(error);
            reject(error);
        });
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3N2LXBhcnNlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9lcHMvZXh0cmFjdG9yL2hhbmRsZXJzL3RhY28tcGFyc2VyL2Nzdi1wYXJzZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGtEQUFxQztBQUNyQywwQ0FBbUI7QUFDbkIsd0RBQTRCO0FBQzVCLGlEQUFvQztBQUVwQywwRkFBMEU7QUFJMUUsMERBQXFGO0FBQ3JGLDREQUFzRDtBQUN0RCxpRUFBd0Q7QUFFeEQsb0NBQW9DO0FBQ3BDLElBQU0sb0JBQW9CLEdBQUcsQ0FBQyxDQUFBO0FBQzlCLElBQU0saUJBQWlCLEdBQUcsR0FBRyxDQUFBO0FBRTdCO0lBQW1DLGlDQUFjO0lBUS9DLHVCQUFvQixlQUFnQyxFQUFVLFdBQW1CLEVBQVUsUUFBZ0I7UUFBM0csWUFDRSxpQkFBTyxTQUVSO1FBSG1CLHFCQUFlLEdBQWYsZUFBZSxDQUFpQjtRQUFVLGlCQUFXLEdBQVgsV0FBVyxDQUFRO1FBQVUsY0FBUSxHQUFSLFFBQVEsQ0FBUTtRQU5uRyxXQUFLLEdBQUcsb0JBQW9CLENBQUE7UUFDNUIsaUJBQVcsR0FBRyxJQUFJLENBQUE7UUFPeEIsS0FBSSxDQUFDLFFBQVEsR0FBRyxLQUFJLENBQUMsZUFBZSxDQUFDLG1CQUFtQixDQUFDLEtBQUksQ0FBQyxXQUFXLEVBQUUsS0FBSSxDQUFDLFFBQVEsQ0FBQyxDQUFBOztJQUMzRixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0csd0NBQWdCLEdBQXRCOzs7Ozs7NEJBQ3NCLHFCQUFNLElBQUksQ0FBQyxzQkFBc0IsRUFBRTt3QkFFdkQsYUFBYTtzQkFGMEM7O3dCQUFqRCxXQUFXLEdBQUcsU0FBbUM7d0JBRXZELGFBQWE7d0JBQ2IsSUFBSSxX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