"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getInMemoryCodeText = void 0;
function getInMemoryCodeText(fetcherClassName, parserClassName) {
    return "\n        const fetcher = new globalRefs[\"".concat(fetcherClassName, "\"]();\n        const parser = new globalRefs[\"").concat(parserClassName, "\"]();\n\n        const handlerInput = $0.copySync();\n        const context = $1.copySync();\n\n        if (!context.connector) {\n          log('context.connector is not set.');\n        }\n\n        return (async () => {\n          try {\n            const { authResult, connector: { secrets }, phase } = context;\n\n            if (phase !== \"SchemaGathering\" && phase !== \"DataGathering\") {\n              throw new Error('The phase \"' + phase + '\" is not a valid GatheringPhase.');\n            }\n\n            const fetchIter = fetcher.fetch({ authResult, handlerInput, secrets });\n            if (typeof fetchIter?.next !== 'function') {\n              throw new Error(\"").concat(fetcherClassName, ".fetch is not a generator function.\");\n            }\n\n            let dataContainer = createDataContainer();\n\n            while (true) {\n              let fetchResult;\n              try {\n                fetchResult = await fetchIter.next();\n              } catch (error) {\n                error.message = '").concat(fetcherClassName, ".fetch failed. ' + error.message;\n                throw error;\n              }\n\n              const { value, done } = fetchResult;\n              if (done) {\n                break;\n              }\n\n              try {\n                const parseOptions = {\n                  dataContainer,\n                  handlerInput,\n                }\n\n                if (parser instanceof AsyncParser) {\n                  dataContainer = await parser.parse(value, parseOptions);\n                } else {\n                  dataContainer = parser.parse(value, parseOptions);\n                }\n\n                if (!dataContainer || !Array.isArray(dataContainer.tables)) {\n                  throw new Error(\"A proper dataContainer was not returned.\");\n                }\n              } catch (error)  {\n                error.message = '").concat(parserClassName, ".parse failed. ' + error.message;\n                throw error;\n              }\n\n              log('pipeline table count after parser.run is ' + dataContainer.tables.length);\n\n              // Next step: flush container's table's rows to disk.\n              // store.run(handlerInput, context);\n              // TODO: we should spike on how to achieve this ^\n\n            }\n            return dataContainer;\n          }\n          catch (error) {\n            error.message = 'Failure in sandbox pipeline. ' + error.message;\n            throw error;\n          }\n        })();\n        ");
}
exports.getInMemoryCodeText = getInMemoryCodeText;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW4tbWVtb3J5LWNvZGUtdGV4dC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9lcHMvZXh0cmFjdG9yL2luLW1lbW9yeS1jb2RlLXRleHQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsU0FBZ0IsbUJBQW1CLENBQUMsZ0JBQXdCLEVBQUUsZUFBdUI7SUFDbkYsT0FBTyxxREFDaUMsZ0JBQWdCLDZEQUNqQixlQUFlLDRyQkFtQnZCLGdCQUFnQiwyVUFVZCxnQkFBZ0IsODFCQXlCaEIsZUFBZSw0bEJBa0J6QyxDQUFBO0FBQ1QsQ0FBQztBQTVFRCxrREE0RUMifQ==