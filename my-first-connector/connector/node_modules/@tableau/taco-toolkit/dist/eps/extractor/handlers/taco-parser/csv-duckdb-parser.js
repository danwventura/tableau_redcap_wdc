"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CsvDuckdbTacoParser = void 0;
var fs_1 = __importDefault(require("fs"));
var duckdb_async_1 = require("duckdb-async");
var base_taco_file_parser_1 = require("./base-taco-file-parser");
var column_header_property_1 = require("../../../../shared/enums/column-header-property");
var parse_utils_1 = require("../../../utils/parse-utils");
var FIRST_DATA_ROW_INDEX = 0;
var CsvDuckdbTacoParser = /** @class */ (function (_super) {
    __extends(CsvDuckdbTacoParser, _super);
    function CsvDuckdbTacoParser(tempDataManager, extractorId, filename) {
        var _this = _super.call(this) || this;
        _this.tempDataManager = tempDataManager;
        _this.extractorId = extractorId;
        _this.filename = filename;
        _this.index = FIRST_DATA_ROW_INDEX;
        _this.hasMoreRows = true;
        _this.filepath = _this.tempDataManager.getTempDataFilePath(_this.extractorId, _this.filename);
        return _this;
    }
    /**
     * Set columns metadata info to the parser. When columnHeaders are set, getColumnHeaders will
     * respect the given info. Otherwise, all fields are assumed as string type.
     *
     * To prevent the method from being misused, this method can be called once, otherwise,
     * it throws an error.
     */
    CsvDuckdbTacoParser.prototype.setColumnHeaders = function (columnHeaders) {
        var e_1, _a;
        if (this.columnHeaderMap) {
            throw new Error('CsvDuckdbTacoParser.setColumnHeaders(): columnHeaders can be only set once.');
        }
        this.columnHeaderMap = new Map();
        try {
            for (var columnHeaders_1 = __values(columnHeaders), columnHeaders_1_1 = columnHeaders_1.next(); !columnHeaders_1_1.done; columnHeaders_1_1 = columnHeaders_1.next()) {
                var columnHeader = columnHeaders_1_1.value;
                var id = columnHeader.id;
                if (this.columnHeaderMap.has(id)) {
                    throw new Error("CsvDuckdbTacoParser.setColumnHeaders(): Column name must be unique. Found duplicate column name '".concat(id, "'"));
                }
                this.columnHeaderMap.set(id, columnHeader);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (columnHeaders_1_1 && !columnHeaders_1_1.done && (_a = columnHeaders_1.return)) _a.call(columnHeaders_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * Get ColumnHeaders for a CSV file.
     *
     * By default, it returns all column header fields and all columns are typed as string.
     * If columns metadata is set by setColumnHeaders, it will filter the columns with the given columnHeaders,
     * while the column order from the file is still preserved.
     */
    CsvDuckdbTacoParser.prototype.getColumnHeaders = function () {
        return __awaiter(this, void 0, void 0, function () {
            var db, columnNames, columnHeaders, columnNames_1, columnNames_1_1, columnName, columnHeader;
            var e_2, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.getDb()];
                    case 1:
                        db = _b.sent();
                        return [4 /*yield*/, this.getColumnNamesFromFile(db, this.filepath)
                            // empty file
                        ];
                    case 2:
                        columnNames = _b.sent();
                        // empty file
                        if (columnNames.length === 0) {
                            if (!this.columnHeaderMap) {
                                throw new Error('CsvDuckdbTacoParser.getColumnHeaders(): Failed to find column headers from ingested data. If the table empty, ' +
                                    'column headers must be provided via DataContainer.');
                            }
                            return [2 /*return*/, Array.from(this.columnHeaderMap.values())];
                        }
                        // when columnHeaderMap is NOT present, all columns are selected as string type
                        if (!this.columnHeaderMap) {
                            return [2 /*return*/, columnNames.map(function (columnName) {
                                    return { id: columnName, dataType: column_header_property_1.DataType.String };
                                })];
                        }
                        columnHeaders = [];
                        try {
                            for (columnNames_1 = __values(columnNames), columnNames_1_1 = columnNames_1.next(); !columnNames_1_1.done; columnNames_1_1 = columnNames_1.next()) {
                                columnName = columnNames_1_1.value;
                                columnHeader = this.columnHeaderMap.get(columnName);
                                if (columnHeader) {
                                    columnHeaders.push(columnHeader);
                                }
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (columnNames_1_1 && !columnNames_1_1.done && (_a = columnNames_1.return)) _a.call(columnNames_1);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                        return [2 /*return*/, columnHeaders];
                }
            });
        });
    };
    CsvDuckdbTacoParser.prototype.hasNextRow = function () {
        return this.hasMoreRows;
    };
    CsvDuckdbTacoParser.prototype.resetIndex = function () {
        this.index = FIRST_DATA_ROW_INDEX;
    };
    CsvDuckdbTacoParser.prototype.getRowCount = function () {
        var _a;
        return __awaiter(this, void 0, void 0, function () {
            var db, count;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.getDb()];
                    case 1:
                        db = _b.sent();
                        if (!fs_1.default.existsSync(this.filepath)) {
                            throw new Error("CsvDuckdbTacoParser.getRowCount(): File does not exist." +
                                "Check the logs in case of any error during data ingestion." +
                                "If the source table is empty, consider using FetchUtils.ingestDataRows API.");
                        }
                        return [4 /*yield*/, (0, parse_utils_1.isFileEmpty)(this.filepath)];
                    case 2:
                        if (!!(_b.sent())) return [3 /*break*/, 4];
                        return [4 /*yield*/, db.all("SELECT COUNT(*) AS ROW_COUNT FROM READ_CSV_AUTO('".concat(this.filepath, "', header=True)"))];
                    case 3:
                        count = _b.sent();
                        if (((_a = count[0]) === null || _a === void 0 ? void 0 : _a.ROW_COUNT) !== undefined) {
                            return [2 /*return*/, count[0].ROW_COUNT];
                        }
                        else {
                            throw new Error('CsvDuckdbTacoParser.getRowCount failed.');
                        }
                        _b.label = 4;
                    case 4: return [2 /*return*/, 0];
                }
            });
        });
    };
    /**
     * Get the next set of data rows from the CSV file with the specified count.
     *
     * @param count The number of rows to retrieve.
     *
     * @returns An array of data rows.
     *
     * @throws An error if the count is less than 1 or if the data rows are invalid.
     */
    CsvDuckdbTacoParser.prototype.getNextDataRows = function (count) {
        return __awaiter(this, void 0, void 0, function () {
            var db, columnNames, data;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (count < 1) {
                            throw new Error("CsvDuckdbTacoParser.getNextDataRows(): count value ".concat(count, " should be greater than 0."));
                        }
                        return [4 /*yield*/, this.getDb()];
                    case 1:
                        db = _a.sent();
                        return [4 /*yield*/, this.getColumnNamesFromFile(db, this.filepath)
                            // empty file
                        ];
                    case 2:
                        columnNames = _a.sent();
                        // empty file
                        if (columnNames.length === 0) {
                            if (!this.columnHeaderMap) {
                                throw new Error('CsvDuckdbTacoParser.getNextDataRows(): Failed to find column headers from ingested data. If the table empty, ' +
                                    'column headers must be provided via DataContainer.');
                            }
                            // if columnHeaders is provided, it is valid empty table.
                            this.hasMoreRows = false;
                            return [2 /*return*/, []];
                        }
                        return [4 /*yield*/, parseCsvFile(db, this.filepath, this.index, count + 1)];
                    case 3:
                        data = _a.sent();
                        if (data.length > 0) {
                            this.index += count;
                            if (data.length > count) {
                                this.hasMoreRows = true;
                                data.pop();
                            }
                            else {
                                this.hasMoreRows = false;
                            }
                            if (!(0, parse_utils_1.isValidDataRows)(data)) {
                                throw new Error('CsvDuckdbTacoParser.getNextDataRows(): Invalid Data Rows');
                            }
                            if (this.columnHeaderMap) {
                                return [2 /*return*/, (0, parse_utils_1.composeDataRowsWithTypeFromObjectArray)(data, this.columnHeaderMap)];
                            }
                        }
                        return [2 /*return*/, data];
                }
            });
        });
    };
    CsvDuckdbTacoParser.prototype.getDb = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!!this.db) return [3 /*break*/, 2];
                        _a = this;
                        return [4 /*yield*/, duckdb_async_1.Database.create(':memory:')];
                    case 1:
                        _a.db = _b.sent();
                        _b.label = 2;
                    case 2: return [2 /*return*/, this.db];
                }
            });
        });
    };
    /**
     * Retrieves the column names from the first row of a csv file located at the given file path.
     *
     * @param {Database} db - The duckdb database instance to execute the query against.
     * @param {string} filepath - The file path of the csv file to read from.
     *
     * @returns {Promise<string[]>} - A Promise that resolves with an array of string column names, or an empty array if no column names were found.
     */
    CsvDuckdbTacoParser.prototype.getColumnNamesFromFile = function (db, filepath) {
        return __awaiter(this, void 0, void 0, function () {
            var dbResult;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.headersFromFile && this.headersFromFile.length > 0) {
                            return [2 /*return*/, this.headersFromFile];
                        }
                        if (!fs_1.default.existsSync(this.filepath)) {
                            throw new Error("CsvDuckdbTacoParser.getColumnNamesFromFile(): File does not exist." +
                                "Check the logs in case of any error during data ingestion." +
                                "If the source table is empty, consider using FetchUtils.ingestDataRows API.");
                        }
                        this.headersFromFile = [];
                        return [4 /*yield*/, (0, parse_utils_1.isFileEmpty)(filepath)];
                    case 1:
                        if (!!(_a.sent())) return [3 /*break*/, 3];
                        return [4 /*yield*/, db.all("SELECT * FROM READ_CSV_AUTO('".concat(filepath, "', header=True) LIMIT 1"))];
                    case 2:
                        dbResult = _a.sent();
                        if (dbResult.length > 0) {
                            this.headersFromFile = Object.keys(dbResult[0]).map(function (columnName) {
                                return columnName;
                            });
                        }
                        _a.label = 3;
                    case 3: return [2 /*return*/, this.headersFromFile];
                }
            });
        });
    };
    return CsvDuckdbTacoParser;
}(base_taco_file_parser_1.TacoFileParser));
exports.CsvDuckdbTacoParser = CsvDuckdbTacoParser;
/**
 * Parses a csv file located at the given file path, and returns a subset of its data as an array of objects.
 *
 * @param {Database} db - The Duckdb database instance to execute the query against.
 * @param {string} filepath - The file path of the csv file to read from.
 * @param {number} offset - The zero-based index of the first row to return.
 * @param {number} limit - The maximum number of rows to return.
 *
 * @returns {Promise<TableData>} - A Promise that resolves with an array of objects representing the requested subset of the table data, where each object has properties corresponding to the table columns.
 */
function parseCsvFile(db, filepath, offset, limit) {
    return __awaiter(this, void 0, void 0, function () {
        var result, columnMetadata, castString;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, db.all("DESCRIBE SELECT * FROM READ_CSV_AUTO('".concat(filepath, "', header=True)"))];
                case 1:
                    result = _a.sent();
                    columnMetadata = result.map(function (_a) {
                        var column_name = _a.column_name, column_type = _a.column_type;
                        return ({ column_name: column_name, column_type: column_type });
                    });
                    castString = columnMetadata
                        .map(function (row) {
                        // Replace double quotes with two double quotes for sql parsing
                        var columnName = row.column_name.replace(/"/g, '""');
                        return "CAST(\"".concat(columnName, "\" AS VARCHAR) AS \"").concat(columnName, "\"");
                    })
                        .join(', ');
                    return [4 /*yield*/, db.all("SELECT ".concat(castString, " FROM READ_CSV_AUTO('").concat(filepath, "', header=True) t LIMIT ").concat(limit, " OFFSET ").concat(offset))];
                case 2: 
                // Execute a Duckdb query to retrieve the requested subset of the table data from the csv file.
                return [2 /*return*/, _a.sent()];
            }
        });
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3N2LWR1Y2tkYi1wYXJzZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9zcmMvZXBzL2V4dHJhY3Rvci9oYW5kbGVycy90YWNvLXBhcnNlci9jc3YtZHVja2RiLXBhcnNlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDBDQUFtQjtBQUNuQiw2Q0FBa0Q7QUFHbEQsaUVBQXdEO0FBRXhELDBGQUEwRTtBQUUxRSwwREFBaUg7QUFFakgsSUFBTSxvQkFBb0IsR0FBRyxDQUFDLENBQUE7QUFLOUI7SUFBeUMsdUNBQWM7SUFRckQsNkJBQW9CLGVBQWdDLEVBQVUsV0FBbUIsRUFBVSxRQUFnQjtRQUEzRyxZQUNFLGlCQUFPLFNBRVI7UUFIbUIscUJBQWUsR0FBZixlQUFlLENBQWlCO1FBQVUsaUJBQVcsR0FBWCxXQUFXLENBQVE7UUFBVSxjQUFRLEdBQVIsUUFBUSxDQUFRO1FBTm5HLFdBQUssR0FBRyxvQkFBb0IsQ0FBQTtRQUM1QixpQkFBVyxHQUFHLElBQUksQ0FBQTtRQU94QixLQUFJLENBQUMsUUFBUSxHQUFHLEtBQUksQ0FBQyxlQUFlLENBQUMsbUJBQW1CLENBQUMsS0FBSSxDQUFDLFdBQVcsRUFBRSxLQUFJLENBQUMsUUFBUSxDQUFDLENBQUE7O0lBQzNGLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCw4Q0FBZ0IsR0FBaEIsVUFBaUIsYUFBNkI7O1FBQzVDLElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRTtZQUN4QixNQUFNLElBQUksS0FBSyxDQUFDLDZFQUE2RSxDQUFDLENBQUE7U0FDL0Y7UUFFRCxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksR0FBRyxFQUFFLENBQUE7O1lBQ2hDLEtBQTJCLElBQUEsa0JBQUEsU0FBQSxhQUFhLENBQUEsNENBQUEsdUVBQUU7Z0JBQXJDLElBQU0s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