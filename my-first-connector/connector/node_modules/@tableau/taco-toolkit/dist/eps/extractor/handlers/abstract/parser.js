"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataTableBuilder = exports.DataContainerBuilder = exports.AsyncParser = exports.Parser = void 0;
var BaseParser = /** @class */ (function () {
    function BaseParser() {
    }
    /**
     * A static method to create a DataContainerBuilder instance based on the provided dataContainer object.
     */
    BaseParser.createContainerBuilder = function (dataContainer) {
        if (!isValidDataContainer(dataContainer)) {
            throw new Error('Found invalid DataContainer: ' + JSON.stringify(dataContainer));
        }
        return new DataContainerBuilder(dataContainer);
    };
    return BaseParser;
}());
/**
 * An abstract class for the implementation of connector custom parsing that synchronously parses the results yielded from the Fetcher.
 *
 * For TypeScript, the fetcherResult type can be provided via the type parameter. By default, fetcherResult is typed as `any`.
 *
 * @example
 * ```ts
 * export default class MyParser extends Parser<Uint8Array> {
 *   parse(fetcherResult: Uint8Array, options: ParseOptions): DataContainer {
 *     // ...
 *   }
 * }
 * ```
 */
var Parser = /** @class */ (function (_super) {
    __extends(Parser, _super);
    function Parser() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Parser;
}(BaseParser));
exports.Parser = Parser;
/**
 * An abstract class for the implementation of connector custom parsing that asynchronously parses the results yielded from the Fetcher.
 *
 * For TypeScript, the fetcherResult type can be provided via the type parameter. By default, fetcherResult is typed as `any`.
 *
 * @example
 * ```ts
 * export default class MyParser extends AsyncParser<Uint8Array> {
 *   async parse(fetcherResult: Uint8Array, options: ParseOptions): Promise<DataContainer> {
 *     // ...
 *   }
 * }
 * ```
 */
var AsyncParser = /** @class */ (function (_super) {
    __extends(AsyncParser, _super);
    function AsyncParser() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return AsyncParser;
}(BaseParser));
exports.AsyncParser = AsyncParser;
/**
 * A builder class for constructing and modifying a DataContainer instance.
 *
 * This class provides methods to retrieve, and append tables within a DataContainer.
 *
 * @example
 * ```ts
 * const dataContainerBuilder = Parser.createContainerBuilder(initialDataContainer)
 *
 * // Create or get a table and add columns or rows
 * const { tableBuilder, isNew } = dataContainerBuilder.getTable('myTable')
 * tableBuilder.addColumnHeader({ name: 'column1', dataType: 'string' });
 * tableBuilder.addColumnHeader({ name: 'column2', dataType: 'string' });
 * tableBuilder.addRow({ column1: 'value1', column2: 'value2' });
 *
 * // Get the final DataContainer
 * const finalDataContainer = dataContainerBuilder.getDataContainer()
 * ```
 */
var DataContainerBuilder = /** @class */ (function () {
    // Hide the constructor from the doc. Users should Parser.createContainerBuilder instead.
    /** @ignore */
    function DataContainerBuilder(dataContainer) {
        this.dataContainer = dataContainer;
    }
    /**
     * Retrieves a table builder for the specified table name. If the table does not exist,
     * a new table is created within the DataContainer.
     *
     * @param {string} name - The name of the table.
     * @returns {{ tableBuilder: DataTableBuilder; isNew: boolean }} An object containing the table builder
     * and a boolean indicating whether the table is newly created.
     */
    DataContainerBuilder.prototype.getTable = function (name) {
        var table = this.dataContainer.tables.find(function (t) { return t.name === name; });
        if (table === undefined) {
            var newTable = {
                columns: [],
                id: '',
                name: name,
                properties: {},
                rows: [],
            };
            this.dataContainer.tables.push(newTable);
            return {
                isNew: true,
                tableBuilder: new DataTableBuilder(newTable),
            };
        }
        return { isNew: false, tableBuilder: new DataTableBuilder(table) };
    };
    /**
     * Appends an array of DataTable instances to the DataContainer.
     *
     * @param {DataTable[]} tables - An array of DataTable instances to append.
     */
    /** @ignore */
    DataContainerBuilder.prototype.appendTables = function (tables) {
        for (var i = 0; i < tables.length; i++) {
            this.appendTable(tables[i]);
        }
    };
    /**
     * Appends a DataTable instance to the DataContainer.
     *
     * @param {DataTable} table - The DataTable instance to append.
     * @throws {Error} Throws an error if a table with the same name already exists in the DataContainer.
     */
    /** @ignore */
    DataContainerBuilder.prototype.appendTable = function (table) {
        if (this.dataContainer.tables.find(function (t) { return t.name === table.name; })) {
            throw new Error("Failed to append table. The DataContainer already has a table named '".concat(table.name, "'"));
        }
        this.dataContainer.tables.push(table);
    };
    /**
     * Gets the final DataContainer instance after building and modifying it.
     *
     * @returns {DataContainer} The constructed DataContainer instance.
     */
    DataContainerBuilder.prototype.getDataContainer = function () {
        return this.dataContainer;
    };
    return DataContainerBuilder;
}());
exports.DataContainerBuilder = DataContainerBuilder;
/**
 * A builder class for constructing and modifying a DataTable instance within a DataContainer.
 *
 * This class provides methods to add row/s and add column header/s to a DataTable.
 *
 * @example
 * ```ts
 * const dataContainerBuilder = Parser.createContainerBuilder(initialDataContainer);
 * const { tableBuilder } = dataContainerBuilder.getTable('myTable');
 *
 * // Add row and column header for a specific table
 * tableBuilder.addColumnHeader({ name: 'column1', dataType: 'string' });
 * tableBuilder.addColumnHeader({ name: 'column2', dataType: 'string' });
 * tableBuilder.addRow({ column1: 'value1', column2: 'value2' });
 *
 * // Get the final DataContainer
 * const finalDataContainer = dataContainerBuilder.getDataContainer();
 * ```
 */
var DataTableBuilder = /** @class */ (function () {
    // Hide the constructor from the doc. Users should get this from DataContainerBuilder.
    /** @ignore */
    function DataTableBuilder(dataTable) {
        this.dataTable = dataTable;
    }
    /** @ignore */
    DataTableBuilder.prototype.setId = function (id) {
        this.dataTable.id = id;
    };
    /** @ignore */
    DataTableBuilder.prototype.setProperties = function (properties) {
        this.dataTable.properties = properties;
    };
    /** @ignore */
    DataTableBuilder.prototype.setDeferHandler = function (handlerInput) {
        this.dataTable.properties = __assign(__assign({}, this.dataTable.properties), { handlerInput: handlerInput, isDeferred: true });
    };
    /**
     * Adds a single row to the DataTable.
     *
     * @param {DataRow} row - The row to add to the DataTable.
     */
    DataTableBuilder.prototype.addRow = function (row) {
        this.dataTable.rows.push(row);
    };
    /**
     * Adds multiple rows to the DataTable.
     *
     * @param {DataRow[]} rows - The array of rows to add to the DataTable.
     */
    DataTableBuilder.prototype.addRows = function (rows) {
        var e_1, _a;
        try {
            // using for...of to handle large data.
            // avoid using spread operator which causes maximum stack error.
            for (var rows_1 = __values(rows), rows_1_1 = rows_1.next(); !rows_1_1.done; rows_1_1 = rows_1.next()) {
                var row = rows_1_1.value;
                if (row) {
                    this.addRow(row);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (rows_1_1 && !rows_1_1.done && (_a = rows_1.return)) _a.call(rows_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * Adds a single column header to the DataTable.
     *
     * @param {ColumnHeader} column - The column header to add to the DataTable.
     */
    DataTableBuilder.prototype.addColumnHeader = function (column) {
        this.dataTable.columns.push(column);
    };
    /**
     * Adds multiple column headers to the DataTable.
     *
     * @param {ColumnHeader[]} colHeaders - The array of column headers to add to the DataTable.
     */
    DataTableBuilder.prototype.addColumnHeaders = function (colHeaders) {
        var e_2, _a;
        try {
            // using for...of to handle large data.
            // avoid using spread operator which causes maximum stack error.
            for (var colHeaders_1 = __values(colHeaders), colHeaders_1_1 = colHeaders_1.next(); !colHeaders_1_1.done; colHeaders_1_1 = colHeaders_1.next()) {
                var header = colHeaders_1_1.value;
                if (header) {
                    this.addColumnHeader(header);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (colHeaders_1_1 && !colHeaders_1_1.done && (_a = colHeaders_1.return)) _a.call(colHeaders_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    return DataTableBuilder;
}());
exports.DataTableBuilder = DataTableBuilder;
function isValidDataContainer(value) {
    if (typeof value !== 'object' || value === null) {
        return false;
    }
    return 'metadata' in value && Array.isArray(value.tables);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vc3JjL2Vwcy9leHRyYWN0b3IvaGFuZGxlcnMvYWJzdHJhY3QvcGFyc2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFXQTtJQUFBO0lBVUEsQ0FBQztJQVRDOztPQUVHO0lBQ0ksaUNBQXNCLEdBQTdCLFVBQThCLGFBQTRCO1FBQ3hELElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxhQUFhLENBQUMsRUFBRTtZQUN4QyxNQUFNLElBQUksS0FBSyxDQUFDLCtCQUErQixHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQTtTQUNqRjtRQUNELE9BQU8sSUFBSSxvQkFBb0IsQ0FBQyxhQUFhLENBQUMsQ0FBQTtJQUNoRCxDQUFDO0lBQ0gsaUJBQUM7QUFBRCxDQUFDLEFBVkQsSUFVQztBQUVEOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFDSDtJQUF3RCwwQkFBVTtJQUFsRTs7SUFNQSxDQUFDO0lBQUQsYUFBQztBQUFELENBQUMsQUFORCxDQUF3RCxVQUFVLEdBTWpFO0FBTnFCLHdCQUFNO0FBUTVCOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFDSDtJQUE2RCwrQkFBVTtJQUF2RTs7SUFNQSxDQUFDO0lBQUQsa0JBQUM7QUFBRCxDQUFDLEFBTkQsQ0FBNkQsVUFBVSxHQU10RTtBQU5xQixrQ0FBVztBQVFqQzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBa0JHO0FBQ0g7SUFDRSx5RkFBeUY7SUFDekYsY0FBYztJQUNkLDhCQUFvQixhQUE0QjtRQUE1QixrQkFBYSxHQUFiLGFBQWEsQ0FBZTtJQUFHLENBQUM7SUFFcEQ7Ozs7Ozs7T0FPRztJQUNILHVDQUFRLEdBQVIsVUFBUyxJQUFZO1FBQ25CLElBQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFDLENBQUMsSUFBSyxPQUFBLENBQUMsQ0FBQyxJQUFJLEtBQUssSUFBSSxFQUFmLENBQWUsQ0FBQyxDQUFBO1FBQ3BFLElBQUksS0FBSyxLQUFLLFNBQVMsRUFBRTtZQUN2QixJQUFNLFFBQVEsR0FBRztnQkFDZixPQUFPLEVBQUUsRUFBRTtnQkFDWCxFQUFFLEVBQUUsRUFBRTtnQkFDTixJQUFJLE1BQUE7Z0JBQ0osVUFBVSxFQUFFLEVBQUU7Z0JBQ2QsSUFBSSxFQUFFLEVBQUU7YUFDVCxDQUFBO1lBQ0QsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFBO1lBRXhDLE9BQU87Z0JBQ0wsS0FBSyxFQUFFLElBQUk7Z0JBQ1gsWUFBWSxFQUFFLElBQUksZ0JBQWdCLENBQUMsUUFBUSxDQUFDO2FBQzdDLENBQUE7U0FDRjtRQUVELE9BQU8sRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxJQUFJLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUE7SUFDcEUsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxjQUFjO0lBQ2QsMkNBQVksR0FBWixVQUFhLE1BQW1CO1FBQzlCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ3RDLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUE7U0FDNUI7SUFDSCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSCxjQUFjO0lBQ2QsMENBQVcsR0FBWCxVQUFZLEtBQWdCO1FBQzFCLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQUMsQ0FBQyxJQUFLLE9BQUEsQ0FBQyxDQUFDLElBQUksS0FBSyxLQUFLLENBQUMsSUFBSSxFQUFyQixDQUFxQixDQUFDLEVBQUU7WUFDaEUsTUFBTSxJQUFJLEtBQUssQ0FBQywrRUFBd0UsS0FBSyxDQUFDLElBQUksTUFBRyxDQUFDLENBQUE7U0FDdkc7UUFDRCxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUE7SUFDdkMsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCwrQ0FBZ0IsR0FBaEI7UUFDRSxPQUFPLElBQUksQ0FBQyxhQUFhLENBQUE7SUFDM0IsQ0FBQztJQUNILDJCQUFDO0FBQUQsQ0FBQyxBQXBFRCxJQW9FQztBQXBFWSxvREFBb0I7QUFzRWpDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FrQkc7QUFDSDtJQUNFLHNGQUFzRjtJQUN0RixjQUFjO0lBQ2QsMEJBQW9CLFNBQW9CO1FBQXBCLGNBQVMsR0FBVCxTQUFTLENBQVc7SUFBRyxDQUFDO0lBRTVDLGNBQWM7SUFDZCxnQ0FBSyxHQUFMLFVBQU0sRUFBVTtRQUNkLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQTtJQUN4QixDQUFDO0lBRUQsY0FBYztJQUNkLHdDQUFhLEdBQWIsVUFBYyxVQUFtQztRQUMvQyxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUE7SUFDeEMsQ0FBQztJQUVELGNBQWM7SUFDZCwwQ0FBZSxHQUFmLFVBQWdCLFlBQTBCO1FBQ3hDLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBVSx5QkFBUSxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsS0FBRSxZQUFZLGNBQUEsRUFBRSxVQUFVLEVBQUUsSUFBSSxHQUFFLENBQUE7SUFDOUYsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxpQ0FBTSxHQUFOLFVBQU8sR0FBWTtRQUNqQixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUE7SUFDL0IsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxrQ0FBTyxHQUFQLFVBQVEsSUFBZTs7O1lBQ3JCLHVDQUF1QztZQUN2QyxnRUFBZ0U7WUFDaEUsS0FBa0IsSUFBQSxTQUFBLFNBQUEsSUFBSSxDQUFBLDBCQUFBLDRDQUFFO2dCQUFuQixJQUFNLEdBQUcsaUJBQUE7Z0JBQ1osSUFBSSxHQUFHLEVBQUU7b0JBQ1AsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQTtpQkFDakI7YUFDRjs7Ozs7Ozs7O0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCwwQ0FBZSxHQUFmLFVBQWdCLE1BQW9CO1FBQ2xDLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQTtJQUNyQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILDJDQUFnQixHQUFoQixVQUFpQixVQUEwQjs7O1lBQ3pDLHVDQUF1QztZQUN2QyxnRUFBZ0U7WUFDaEUsS0FBcUIsSUFBQSxlQUFBLFNBQUEsVUFBVSxDQUFBLHNDQUFBLDhEQUFFO2dCQUE1QixJQUFNLE1BQU0sdUJBQUE7Z0JBQ2YsSUFBSSxNQUFNLEVBQUU7b0JBQ1YsSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsQ0FBQTtpQkFDN0I7YUFDRjs7Ozs7Ozs7O0lBQ0gsQ0FBQztJQUNILHVCQUFDO0FBQUQsQ0FBQyxBQW5FRCxJQW1FQztBQW5FWSw0Q0FBZ0I7QUFxRTdCLFNBQVMsb0JBQW9CLENBQUMsS0FBYztJQUMxQyxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsSUFBSSxLQUFLLEtBQUssSUFBSSxFQUFFO1FBQy9DLE9BQU8sS0FBSyxDQUFBO0tBQ2I7SUFFRCxPQUFPLFVBQVUsSUFBSSxLQUFLLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBRSxLQUF1QixDQUFDLE1BQU0sQ0FBQyxDQUFBO0FBQzlFLENBQUMifQ==