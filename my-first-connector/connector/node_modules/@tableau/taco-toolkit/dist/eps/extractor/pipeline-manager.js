"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var node_events_1 = __importDefault(require("node:events"));
var connector_phase_1 = require("../../shared/enums/connector-phase");
var taco_file_parser_1 = require("../../shared/enums/taco-file-parser");
var handler_input_1 = require("../../shared/types/handler-input");
var eps_logger_1 = require("../logging/eps-logger");
var extractor_cache_1 = require("./extractor-cache");
var csv_parser_1 = require("./handlers/taco-parser/csv-parser");
var excel_parser_1 = require("./handlers/taco-parser/excel-parser");
var sandbox_pipeline_1 = __importDefault(require("./sandbox-pipeline"));
var system_utils_1 = require("../utils/system-utils");
var PipelineManager = /** @class */ (function () {
    function PipelineManager(extractorContext, tempDataManager, networkAdapter) {
        this.extractorContext = extractorContext;
        this.tempDataManager = tempDataManager;
        this.networkAdapter = networkAdapter;
        /** pipelines by name (tableName is useful), for initial pipelines table name is undefined. */
        this.pipelinesMap = new Map();
        this.namedPipelineStatus = new Map();
        this.pipelineDoneEmitter = new node_events_1.default();
    }
    PipelineManager.prototype.addInitialPipelines = function (handlerInputs) {
        var name = undefined;
        this.addPipelines(name, handlerInputs);
    };
    PipelineManager.prototype.addNamedPipeline = function (name, handlerInput) {
        if (!this.pipelinesMap.has(name)) {
            this.addPipelines(name, [handlerInput]);
        }
        else {
            eps_logger_1.Logger.info("A named pipeline for '".concat(name, "' already exists, the new one will be skipped!"));
        }
    };
    PipelineManager.prototype.runPhaseOnInitialPipelines = function (phase) {
        var name = undefined;
        return this.runPhase(phase, name);
    };
    PipelineManager.prototype.runPhaseOnNamedPipeline = function (phase, name) {
        return this.runPhase(phase, name);
    };
    /**
     * Update Extractor Cache for File Based Handler Input/s
     * @param handlerInputs
     */
    PipelineManager.prototype.processFileBasedParser = function (handlerInputs) {
        var _a, handlerInputs_1, handlerInputs_1_1;
        var _b, e_1, _c, _d;
        return __awaiter(this, void 0, void 0, function () {
            var handlerInput, excelTacoParser, tables, parser, tableName, CsvDuckdbTacoParser, tableName, ParquetTacoParser, parser, e_1_1;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        _e.trys.push([0, 10, 11, 16]);
                        _a = true, handlerInputs_1 = __asyncValues(handlerInputs);
                        _e.label = 1;
                    case 1: return [4 /*yield*/, handlerInputs_1.next()];
                    case 2:
                        if (!(handlerInputs_1_1 = _e.sent(), _b = handlerInputs_1_1.done, !_b)) return [3 /*break*/, 9];
                        _d = handlerInputs_1_1.value;
                        _a = false;
                        _e.label = 3;
                    case 3:
                        _e.trys.push([3, , 7, 8]);
                        handlerInput = _d;
                        if (!(0, handler_input_1.isFileBasedHandlerInput)(handlerInput)) return [3 /*break*/, 6];
                        if (!(handlerInput.parser === taco_file_parser_1.TacoFileParser.EXCEL)) return [3 /*break*/, 5];
                        excelTacoParser = new excel_parser_1.ExcelTacoParser(this.tempDataManager, this.extractorContext.extractorId, handlerInput.name);
                        return [4 /*yield*/, excelTacoParser.parse()];
                    case 4:
                        tables = _e.sent();
                        (0, extractor_cache_1.mergeTablesIntoExtractorCache)(tables);
                        return [3 /*break*/, 6];
                    case 5:
                        if (handlerInput.parser === taco_file_parser_1.TacoFileParser.CSV ||
                            // For file-based ingestion, data are stored into csv files.
                            // See FetchUtils.ingestDataRows
                            handlerInput.parser === taco_file_parser_1.TacoFileParser.DATA) {
                            parser = void 0;
                            tableName = handlerInput.name;
                            if ((0, system_utils_1.isCentOS)()) {
                                parser = new csv_parser_1.CsvTacoParser(this.tempDataManager, this.extractorContext.extractorId, tableName);
                            }
                            else {
                                CsvDuckdbTacoParser = 
                                // eslint-disable-next-line @typescript-eslint/no-var-requires
                                require('./handlers/taco-parser/csv-duckdb-parser').CsvDuckdbTacoParser;
                                parser = new CsvDuckdbTacoParser(this.tempDataManager, this.extractorContext.extractorId, tableName);
                            }
                            (0, extractor_cache_1.addTacoFileParserIntoCache)(tableName, parser);
                        }
                        else if (handlerInput.parser === taco_file_parser_1.TacoFileParser.PARQUET) {
                            // Built-in parser taco:parquet-file-parser is not supported on Cent OS
                            if ((0, system_utils_1.isCentOS)()) {
                                throw new Error("".concat(handlerInput.parser, " is not supported on Cent OS."));
                            }
                            tableName = handlerInput.name;
                            ParquetTacoParser = 
                            // eslint-disable-next-line @typescript-eslint/no-var-requires
                            require('./handlers/taco-parser/parquet-parser').ParquetTacoParser;
                            parser = new ParquetTacoParser(this.tempDataManager, this.extractorContext.extractorId, handlerInput.name);
                            (0, extractor_cache_1.addTacoFileParserIntoCache)(tableName, parser);
                        }
                        _e.label = 6;
                    case 6: return [3 /*break*/, 8];
                    case 7:
                        _a = true;
                        return [7 /*endfinally*/];
                    case 8: return [3 /*break*/, 1];
                    case 9: return [3 /*break*/, 16];
                    case 10:
                        e_1_1 = _e.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 16];
                    case 11:
                        _e.trys.push([11, , 14, 15]);
                        if (!(!_a && !_b && (_c = handlerInputs_1.return))) return [3 /*break*/, 13];
                        return [4 /*yield*/, _c.call(handlerInputs_1)];
                    case 12:
                        _e.sent();
                        _e.label = 13;
                    case 13: return [3 /*break*/, 15];
                    case 14:
                        if (e_1) throw e_1.error;
                        return [7 /*endfinally*/];
                    case 15: return [7 /*endfinally*/];
                    case 16: return [2 /*return*/];
                }
            });
        });
    };
    PipelineManager.prototype.waitForPipelineToComplete = function (name) {
        var _this = this;
        return new Promise(function (resolve) {
            _this.pipelineDoneEmitter.once(name, function () {
                resolve();
            });
        });
    };
    /**
     * Run a whole pipeline cycle for particular table with the given HandlerInput.
     * This is used by the deferred pipeline flow when a DataTable has a deferred HandlerInput.
     *
     * The API will register the table name and handlerInput to pipeline manager before
     * running the pipeline, so the caller does NOT need to call addNamedPipeline beforehand.
     * .
     */
    PipelineManager.prototype.runNamedPipeline = function (name, handlerInput) {
        return __awaiter(this, void 0, void 0, function () {
            var state;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        state = this.namedPipelineStatus.get(name);
                        if (state === 'Done') {
                            return [2 /*return*/];
                        }
                        if (!(state === 'Started')) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.waitForPipelineToComplete(name)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                    case 2:
                        this.addNamedPipeline(name, handlerInput);
                        this.namedPipelineStatus.set(name, 'Started');
                        return [4 /*yield*/, this.runPhaseOnNamedPipeline(connector_phase_1.ConnectorPhase.Auth, name)];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, this.runPhaseOnNamedPipeline(connector_phase_1.ConnectorPhase.SchemaGathering, name)];
                    case 4:
                        _a.sent();
                        return [4 /*yield*/, this.processFileBasedParser([handlerInput])];
                    case 5:
                        _a.sent();
                        this.namedPipelineStatus.set(name, 'Done');
                        this.pipelineDoneEmitter.emit(name);
                        this.pipelineDoneEmitter.removeAllListeners(name);
                        return [2 /*return*/];
                }
            });
        });
    };
    PipelineManager.prototype.isNamedPipelineComplete = function (name) {
        return this.namedPipelineStatus.get(name) === 'Done';
    };
    PipelineManager.prototype.addPipelines = function (name, handlerInputs) {
        var _this = this;
        this.pipelinesMap.set(name, handlerInputs.map(function (hi) { return new sandbox_pipeline_1.default(_this.extractorContext, hi, _this.tempDataManager, _this.networkAdapter); }));
    };
    PipelineManager.prototype.runPhase = function (phase, name) {
        return __awaiter(this, void 0, void 0, function () {
            var pipelines, promises;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        pipelines = this.pipelinesMap.get(name);
                        if (pipelines === undefined) {
                            throw new Error("No pipelines named '".concat(name, "' exist."));
                        }
                        promises = pipelines.map(function (pl) { return pl.runPhase(phase); });
                        return [4 /*yield*/, Promise.all(promises)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    return PipelineManager;
}());
exports.default = PipelineManager;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGlwZWxpbmUtbWFuYWdlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9lcHMvZXh0cmFjdG9yL3BpcGVsaW5lLW1hbmFnZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsNERBQXNDO0FBRXRDLHNFQUFtRTtBQUNuRSx3RUFBb0U7QUFDcEUsa0VBQXdGO0FBRXhGLG9EQUE4QztBQUM5QyxxREFBNkY7QUFFN0YsZ0VBQWlFO0FBQ2pFLG9FQUFxRTtBQUNyRSx3RUFBZ0Q7QUFFaEQsc0RBQWdEO0FBTWhEO0lBQ0UseUJBQ1UsZ0JBQWtDLEVBQ2xDLGVBQWdDLEVBQ2hDLGNBQThCO1FBRjlCLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBa0I7UUFDbEMsb0JBQWUsR0FBZixlQUFlLENBQWlCO1FBQ2hDLG1CQUFjLEdBQWQsY0FBYyxDQUFnQjtRQUd4Qyw4RkFBOEY7UUFDdEYsaUJBQVksR0FBRyxJQUFJLEdBQUcsRUFBeUMsQ0FBQTtRQUMvRCx3QkFBbUIsR0FBRyxJQUFJLEdBQUcsRUFBK0IsQ0FBQTtRQUU1RCx3QkFBbUIsR0FBRyxJQUFJLHFCQUFZLEVBQUUsQ0FBQTtJQU43QyxDQUFDO0lBUUosNkNBQW1CLEdBQW5CLFVBQW9CLGFBQXNDO1FBQ3hELElBQU0sSUFBSSxHQUFHLFNBQVMsQ0FBQTtRQUN0QixJQUFJLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxhQUFhLENBQUMsQ0FBQTtJQUN4QyxDQUFDO0lBRUQsMENBQWdCLEdBQWhCLFVBQWlCLElBQVksRUFBRSxZQUEwQjtRQUN2RCxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDaEMsSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFBO1NBQ3hDO2FBQU07WUFDTCxtQkFB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