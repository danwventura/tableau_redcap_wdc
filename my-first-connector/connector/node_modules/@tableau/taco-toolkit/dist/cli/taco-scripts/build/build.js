"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildConnector = void 0;
var core_1 = __importDefault(require("@parcel/core"));
var fs_1 = __importDefault(require("fs"));
var path_1 = __importDefault(require("path"));
var error_codes_1 = require("../../../shared/errors/error-codes");
var error_source_1 = require("../../../shared/errors/error-source");
var status_code_1 = require("../../../shared/errors/status-code");
var command_1 = require("../../taco-commands/utils/command");
var connector_1 = require("../../taco-commands/utils/connector");
var constants_1 = require("../../taco-commands/utils/constants");
var logging_1 = require("../../taco-commands/utils/logging");
var parcel_error_1 = require("./parcel-error");
var connector_handlers_1 = require("./connector-handlers");
function buildConnector(tacoRootPath, state) {
    return __awaiter(this, void 0, void 0, function () {
        var spinner, appResult, handlersResult, copyResult;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    spinner = state.spinner;
                    spinner.info('Start building taco connector');
                    spinner.start('Compiling app and handlers...');
                    return [4 /*yield*/, buildConnectorsApp(tacoRootPath)];
                case 1:
                    appResult = _a.sent();
                    if ((0, command_1.isErrorResult)(appResult)) {
                        spinner.fail('Failed to build connector/app');
                        (0, logging_1.logFatalError)(appResult.error);
                        process.exit(constants_1.TACO_COMMAND_ERROR_EXIT_CODE);
                    }
                    return [4 /*yield*/, buildConnectorsHandlers(tacoRootPath)];
                case 2:
                    handlersResult = _a.sent();
                    if ((0, command_1.isErrorResult)(handlersResult)) {
                        spinner.fail('Failed to build connector/handlers');
                        (0, logging_1.logFatalError)(handlersResult.error);
                        process.exit(constants_1.TACO_COMMAND_ERROR_EXIT_CODE);
                    }
                    spinner.success('Successfully compiled app and handlers');
                    spinner.start('Mounting connector.json...');
                    return [4 /*yield*/, copyConnectorJson(tacoRootPath)];
                case 3:
                    copyResult = _a.sent();
                    if ((0, command_1.isErrorResult)(copyResult)) {
                        spinner.fail('Failed to mount connector.json');
                        (0, logging_1.logFatalError)(copyResult.error);
                        process.exit(constants_1.TACO_COMMAND_ERROR_EXIT_CODE);
                    }
                    spinner.success('Successfully mounted connector.json');
                    spinner.success('Build succeeded!');
                    return [2 /*return*/];
            }
        });
    });
}
exports.buildConnector = buildConnector;
function createParcel(entries, target) {
    var parcelConfigPath = require.resolve('@parcel/config-default');
    logging_1.logger.debug("Compiling ".concat(target, " with default parcel config at: ").concat(parcelConfigPath));
    var options = {
        entries: entries,
        defaultConfig: parcelConfigPath,
        mode: 'development',
        targets: [target],
        logLevel: 'error',
        shouldContentHash: false,
        shouldDisableCache: true,
    };
    return new core_1.default(options);
}
function buildConnectorComponent(sourceType, entries) {
    return __awaiter(this, void 0, void 0, function () {
        var bundler, err_1, errMsg;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    bundler = createParcel(entries, sourceType);
                    return [4 /*yield*/, bundler.run()];
                case 1:
                    _a.sent();
                    return [2 /*return*/, { state: 'success' }];
                case 2:
                    err_1 = _a.sent();
                    errMsg = "Connector ".concat(sourceType, " failed to build: ").concat((0, parcel_error_1.formatParcelError)(err_1), ".");
                    return [2 /*return*/, {
                            state: 'error',
                            error: {
                                statusCode: status_code_1.StatusCode.Cancelled,
                                errorSource: error_source_1.ErrorSources.Client,
                                errorCode: error_codes_1.ErrorCodes.ZUWGQ7DL,
                                message: errMsg,
                                error: err_1,
                            },
                        }];
                case 3: return [2 /*return*/];
            }
        });
    });
}
function buildConnectorsApp(tacoRootPath) {
    return __awaiter(this, void 0, void 0, function () {
        var indexFile;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    indexFile = path_1.default.resolve((0, connector_1.getConnectorAppPath)(tacoRootPath), 'index.html');
                    return [4 /*yield*/, buildConnectorComponent('app', [indexFile])];
                case 1: return [2 /*return*/, _a.sent()];
            }
        });
    });
}
function buildConnectorsHandlers(tacoRootPath) {
    return __awaiter(this, void 0, void 0, function () {
        var entryFiles, error, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    entryFiles = (0, connector_handlers_1.preProcessHandlers)(tacoRootPath);
                    error = (0, connector_handlers_1.validateEntryFileNames)(entryFiles);
                    if (error !== undefined) {
                        return [2 /*return*/, {
                                state: 'error',
                                error: error,
                            }];
                    }
                    return [4 /*yield*/, buildConnectorComponent('handlers', entryFiles)];
                case 1:
                    result = _a.sent();
                    if ((0, command_1.isSuccessResult)(result)) {
                        (0, connector_handlers_1.postProcessHandlers)(tacoRootPath);
                    }
                    return [2 /*return*/, result];
            }
        });
    });
}
function copyConnectorJson(tacoRootPath) {
    return __awaiter(this, void 0, void 0, function () {
        var connectorJsonPath, destFilePaths, results, failures;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    connectorJsonPath = (0, connector_1.getConnectorJsonPath)(tacoRootPath);
                    destFilePaths = connector_1.sourceTypes.map(function (sourceType) {
                        return path_1.default.join(tacoRootPath, 'dist', sourceType, 'connector.json');
                    });
                    logging_1.logger.debug("Copying ".concat(connectorJsonPath, " to ").concat(destFilePaths.join(', ')));
                    return [4 /*yield*/, Promise.allSettled(destFilePaths.map(function (destFilePath) {
                            return fs_1.default.promises.copyFile(connectorJsonPath, destFilePath);
                        }))];
                case 1:
                    results = _a.sent();
                    failures = results.filter(function (result) { return result.status === 'rejected'; });
                    if (failures.length > 0) {
                        return [2 /*return*/, {
                                state: 'error',
                                error: {
                                    statusCode: status_code_1.StatusCode.Cancelled,
                                    errorSource: error_source_1.ErrorSources.Client,
                                    errorCode: error_codes_1.ErrorCodes.ZUWGQ7DL,
                                    message: failures.toString(),
                                },
                            }];
                    }
                    return [2 /*return*/, { state: 'success' }];
            }
        });
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVpbGQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY2xpL3RhY28tc2NyaXB0cy9idWlsZC9idWlsZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxzREFBaUM7QUFFakMsMENBQW1CO0FBQ25CLDhDQUF1QjtBQUN2QixrRUFBK0Q7QUFDL0Qsb0VBQWtFO0FBQ2xFLGtFQUErRDtBQUMvRCw2REFBMEc7QUFDMUcsaUVBSzRDO0FBQzVDLGlFQUFrRjtBQUNsRiw2REFBcUY7QUFDckYsK0NBQWtEO0FBQ2xELDJEQUFzRztBQUV0RyxTQUFzQixjQUFjLENBQUMsWUFBb0IsRUFBRSxLQUFxQjs7Ozs7O29CQUN0RSxPQUFPLEdBQUssS0FBSyxRQUFWLENBQVU7b0JBRXpCLE9BQU8sQ0FBQyxJQUFJLENBQUMsK0JBQStCLENBQUMsQ0FBQTtvQkFDN0MsT0FBTyxDQUFDLEtBQUssQ0FBQywrQkFBK0IsQ0FBQyxDQUFBO29CQUM1QixxQkFBTSxrQkFBa0IsQ0FBQyxZQUFZLENBQUMsRUFBQTs7b0JBQWxELFNBQVMsR0FBRyxTQUFzQztvQkFDeEQsSUFBSSxJQUFBLHVCQUFhLEVBQUMsU0FBUyxDQUFDLEVBQUU7d0JBQzVCLE9BQU8sQ0FBQyxJQUFJLENBQUMsK0JBQStCLENBQUMsQ0FBQTt3QkFDN0MsSUFBQSx1QkFBYSxFQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQTt3QkFDOUIsT0FBTyxDQUFDLElBQUksQ0FBQyx3Q0FBNEIsQ0FBQyxDQUFBO3FCQUMzQztvQkFFc0IscUJBQU0sdUJBQXVCLENBQUMsWUFBWSxDQUFDLEVBQUE7O29CQUE1RCxjQUFjLEdBQUcsU0FBMkM7b0JBQ2xFLElBQUksSUFBQSx1QkFBYSxFQUFDLGNBQWMsQ0FBQyxFQUFFO3dCQUNqQyxPQUFPLENBQUMsSUFBSSxDQUFDLG9DQUFvQyxDQUFDLENBQUE7d0JBQ2xE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